# 准备的面试八股文
## 1、JS的数据类型
 - 基本数据类型：Number,String,null,undefined,Boolen
 - 引用类型：function,Date,Array,Object
 - es6新增：symbol,set等
 
_两者区别_:
基本数据类型占用内存少，在栈内存中，方便查找，没有相互赋值共享问题。
引用类型在堆内存中，用引用指向，有赋值共享问题

## 2、变量类型检测
typeof:基本数据类型
instanceof:包装类String() Number()
constructor 局限性
Object.prototype.toStrong.call()
```js
var opt = Object.prototype.toString
console.log(opt('123'))
```
包装类：为了访问不报错，临时创建包装类，销毁

## 3、手动实现一个instanceof
```javascript
function instanceof2(Op,Yp){
    let O = Op
    let Y = Yp.prototype
    while(O !== null){
        if(O === Y){
            return true
        }
        Op = Op.__proto__
    }
    return false
}
```
## 4、http和https的区别
 - http是超文本传输协议，基于请求-响应，是明文传输，端口80
 - https是安全超文本传输协议，使用ssl加密传输协议，ssl需要ca发放的证书，是非对称加密，确保数据传输的安全，端口443

## 5、http状态码
 - 1XX：正在请求
 - 2XX：请求成功
 - 3XX：重定向
 - 4XX：客户端错误
 - 5XX：服务端错误


## 6、说一下闭包
函数嵌套函数，内层函数访问外层函数的作用域，内层函数的返回会被保存下来， 
```javascript
function init(name){
    return function displayname(){
	    console.log(name)
    }
}
var fo = init('123')
fo()
```

应用场景：
 - 创建私有变量
 - 延长变量的生命周期，可重复使用的变量
 - 防抖，节流
 - 函数嵌套函数避免全局污染

优缺点：
 - 一直存在内存中，不会被垃圾回收机制回收
 - 避免全局变量的污染
 - 私有变量的存在
 - 闭包较多时，会消耗内存，导致性能下降，在IE浏览器中可能导致内存泄露
 - 用完赋值为null

垃圾回收机制
 - 标记清除：变量离开环境标记为离开环境，被回收内存
 - 引用计数：计数为0被清除，声明后次数+1，同一个值被赋值给另一个变量，次数+1，引用类型值被赋值为其他引用则-1

## 7、说一下this指向
指向函数当前的调用者
 - 定时器中的this指向window
 - 找不到调用者指向window
 - 箭头函数指向

固定函数的执行者
 - bind()返回新的函数
 - call()
 - apply()

## 8、防抖和节流
防抖(Debounce)：
 - 在一定时间内只执行最后一次
 - 搜索框搜索输入
 - 文本保存
 - 使用定时器
```javascript
let timerId = null
function debounce(){
    if(timerId !== null){
        clearTimeout(timerId)
    }
    timerId = setTimeout(()=>{
        console.log(123)
    }, 1000)
}

```
节流（Throttle）:
 - 在一定时间内只执行一次函数
 - 快速点击，鼠标滑动，scroll事件，resize事件，下拉加载，视频播放时间记录

```javascript
let timerId = null
function Throttle(){
    if(timerId !== null){
        return
    }
    timerId = setTimeout(()=>{
        console.log(123)
        timerId = null
    },100)
}
```
 - lodash库中的Debounce和Throttle

## 9、说一说事件循环 
1. 单线程，同步异步
2. 同步给js引擎（微任务），异步给宿主环境（宏任务）
3. 同步放入执行栈，异步等待时机放入任务队列排队
4. 执行栈完成后，完成任务队列，反复循环查看执行，就是事件循环

## 10、说一说原型和原型链以及其查找过程
 - 原型就是每个对象隐藏的Prototype属性指向原型对象
 - 使用__proto__访问，原型链是属性查找的路径，从对象沿原型链向上直至null
 - 使用prototype共享方法，new绑定原型
 - 所有对象最终继承自Object.prototype
 - 函数才有prototype属性（构造函数），对象有__proto__
 - class语法糖，ES6，本质还是原型链

## 11、说一下Promise
 - promise主要有两个参数，三个状态，resolve参数是个函数，同时表示请求成功，执行.then函数，reject是表示请求失败，执行.catch，状态分为pedding初始状态，fulfilled操作成功，rejected操作失败，状态一经改变，不会再变。
 - .then返回的也是一个promise对象 .then(onFulfilled,onRejected)

## 12、TCP三次握手四次挥手
**三次握手**
1. 客户端发送SYN=1（同步标识），ACK=0(确认标识)，随机序号seq=x
2. 服务端接收到消息，发送SYN=1，ACK=1，ack=x+1（确认号）,seq=y
3. 客户端收到服务端的确认后，检查ACK==1，ack==x+1,是的话则发送ACK=1,ack=y+1,让服务端再确认

**四次挥手**

两端都能发起
1. 客户端发起FIN+1 ACK=0,seq = x
2. 服务端确认后发送ACK = 1，ack=x+1 ,seq=y
3. 等待剩余数据传输完成，服务端发送ACK=1 FIN=1 ack=x+1 seq=y
4. 客户端收到FIN=1和ACK=1后发送ACK=1，ack=y+1 seq=y+1

## 13、OSI七层模型
 - 应用层：为软件之间的通信设的接口
 - 表示层：把数据转化为兼容的格式
 - 会话层：不同机器上建立的会话点，维护连接通信
 - 传输层：把传输表头加至数据形成数据包
 - 网络层：将网络表头加至数据包，决定数据的路径选择和转寄
 - 数据链路层：网络寻址，错误侦测和改错
 - 物理层：使用线缆，针脚，电压等方式传输原始比特流数据
## 14、TCP/IP四层模型
 - 应用层：是直接为应用进程提供服务的层
 - 传输层：主要是有可靠传输的TCP协议，特别高效的UDP协议。主要负责传输应用层的数据包。
 - 网络层：寻址建立网络连接
 - 链路层：在物理链路上传输数据帧
## 15、手写深拷贝
```javascript
function deepClone(obj = {}){
    if(obj === null || typeof obj !== 'object'){
        return obj
    }
    let result = {}
    if(Array.isArray(obj)){
        result = []
    }
    for(let key in obj){
        if(obj.hasOwnProperty(key)){
            result[key] = deepClone(obj[key])
        }
    }
    return result
}
```
 - 循环引用导致无限递归
 - 特殊类型，日期对象，正则表达式，原型链没保留，都指向的Object.prototype
 - 无法复制Symbol属性
 - 使用lodash库中的_.cloneDeep

## 16、promise.all
ES6中将多个Promise实例包装成一个Promise实例的方法
```javascript
let p1 = new Promise((resolve,reject) => {
    resolve("p1")
})
let p2 = new Promise((resolve,reject) => {
    reject("p2")
}).catch((resolve)=>{
    resolve('p22')
})
let p3 = new Promise((resolve,reject) => {
    resolve("p3")
})
let pAll = Promise.all([p1,p2,p3])
pAll.then(res=>{
    console.log(res)
})
```
pAll的状态是由三个共同决定的，都成功pAll才成功，多个失败只会捕获第一个

## 17、手写一个promise.all
```javascript
const myPromiseAll = (arr) => {
    return new Promise((resolve,reject) => {
        if(!Array.isArray(arr)){
            throw new TypeError('arguments must be a array')
        }
        var len = arr.length
        var resolveResult = []
        for(let i = 0 ; i < len ; i++){
            arr[i].then(data => {
                resolveResult.push(data)
                if(i == len - 1) resolve(resolveResult)
            }).catch(err => {
                return reject(err)
            })
        }
        
    })
}
```

## 18、HTTP/1.1 HTTP/2 HTTP/3 区别
1. 传输协议：
     - HTTP/1.1 基于TCP文本传输
     - HTTP/2 基于TCP二进制分帧
     - HTTP/3 基于UDP+QUIC（新传输协议）
2. 核心问题（队头阻塞）
     - HTTP/1.1 存在队头阻塞
     - HTTP/2 使用多路复用缓解，没有彻底解决
     - HTTP/3 基于QUIC，彻底解决
3. 关键特性：
     - HTTP/1.1 持久连接，管道化
     - HTTP/2 头部压缩，多路复用，服务器推送，需要HTTPS配个
     - HTTP/3 更快的握手，连接迁移，网络切断不断连，TLS加密

从TCP到UDP+QUIC，从文本到二进制，从解决应用层阻塞到彻底消除传输层阻塞，逐步优化弱网体验

## 19、Vue和React的区别
 - Vue采用模板语法和声明式渲染，上手门槛低；react使用JSX和函数式组件，强调组件组合与单向数据流，更注重逻辑复用和底层灵活
## 20、Vue3的生命周期
 - beforCreate：实例创建之前，数据是未加载状态
 - created：在实例、数据加载后，能初始化数据，DOM渲染之前执行
 - beforeMounted：虚拟DOM已经创建完毕，在数据渲染前最后一次更改数据，el未挂载
 - mounted：页面、数据渲染完成，el挂载完毕，可访问DOM节点
 - beforeUpdate：重新渲染之前触发
 - updated：数据更新完成，DOM也重新render完成，更改数据会陷入死循环
 - beforeUnmount：实例销毁之前
 - unounted：实例销毁后执行
## 21、说一下MVVM
 - 是一种软件架构模式，核心是ViewModel作为桥梁实现数据与视图的双向绑定，避免开发者直接操作DOM，让数据变化自动反映到视图，视图交互也能自动更新数据，从而简化前端开发中的状态管理和视图更新逻辑。
 - 核心组成部分：
    - Model：数据模型，负责存储和管理业务数据
    - View: 用户界面，负责展示数据和接收用户交互
    - ViewModel: 连接二者的中间层，通过数据绑定将Model的变化自动同步到View，同时将View的交互转化为对Model的操作
 - 核心优势：解耦数据与视图，提升代码的可维护性，简化复杂交互场景的卡发
## 22、Vue-Router是干什么的
是Vue的官方路由管理器，用于实现单页面应用的路由功能，它通过路径与组件映射实现页面切换，支持路由参数，导航守卫，懒加载等功能。让单页面应用在不刷新整个页面的情况下更新视图
## 23、Vue-Router的路由模式
 - hash模式，在URL后带#
     - 兼容性好，无需服务器配置
     - 带#不够美观
     - SEO（搜索引擎优化）效果差，爬虫无法正确解析，难以跟踪用户行为
 - history模式
     - URL更加美观，不带#
     - 需要服务端配置支持，兼容性较差
     - SEO效果好

_拓展问题_：如何优化SEO？
 - 使用服务端渲染SSR
 - 使用预渲染技术生成静态HTML页面
 - 使用合适的meta标签描述网页内容，包括标题，描述，关键字
 - 通过robots.txt文件确保SPA中的页面内容能够被搜索引擎爬虫访问到

## 24、js跨域问题
浏览器的同源策略限制（协议、域名、端口不同）的跨域请求
解决方法：
1. CORS(跨域资源共享)
	服务器设置响应头Access-Control-Allow-Origin
2. JSONP
   利用`<script>`标签不受同源限制，只支持GET请求
3. 代理服务器
   开发环境用Dev Server代理，生产环境用Nginx反向代理
4. WebSocket
   基于TCP协议，不受同源策略限制
## 25、事件模型，事件委托
**事件模型**:
 - 原始事件模型
	 - 直接在HTML标签或JS中绑定事件（onclick）
	 - 每个元素只能绑定一个同类事件，会被覆盖
 - DOM2级事件模型
	 - 使用addEventListener绑定事件，支持多个回调
	 - 事件流分为三个阶段：捕获->目标->冒泡
**事件委托**：
 - 利用事件冒泡，将事件监听器绑定到父级元素，通过event.target判断触发源
 - 减少DOM操作
 - 列表项点击
 
```js
document.querySelector('ul').addEventListener('click',(e)=>{
	if(e.target.tagName === 'li'){
		console.log(e.target.textContent)
	}
})
```
## 26、实现trim方法
```js
String.prototype.trimFunc = function(){
    if(this === null){
        return undefined
    }
    let temp = this.slice(0,-1)
    let i = 0
    let j = temp.length - 1
    while(i<j){
        if(temp.charAt(i) === ' ') i++;
        if(temp.charAt(j) === ' ') j--;
        if(temp.charAt(i) !== ' ' && temp.charAt(j) !== ' ') break;
    }
    return this.slice(i,j+1)
}
```
## 27、实现模板字符串的过程
```js
function render(template,data){
    const regex = /\$\{([^}]+)\}/g
    return template.replace(regex,(_,variable)=>{
        return data[variable.trim()] || '';
    })
}
```
## 28、css实现三栏布局（双翼飞，圣杯布局）
 - float+负边距
```html
<body>
    <div class="container">
        <div class="left"></div>
        <div class="mid"></div>
        <div class="right"></div>
    </div>
    
</body>
<style>
    .container{
        padding:0 400px;
        background-color: aqua;
        overflow: hidden;
    }
    .left{
        position: relative;
        height:400px;
        width:400px;
        background-color:blue;
        float:left;
        margin-left: -400px;
    }
    .mid{
        height:400px;
        width: 100%;
        background-color:yellow;
        float: left;
        min-width: 100px;
    }
    .right{
        position: relative;
        height:400px;
        width:400px;
        float:left;
        background-color:green;
        margin-right: -400px;
    }
</style>
```
*注意*：三个盒子都要设置成float属性
## 29、实现一个继承
 - class语法糖
```js
class Person{
    constructor(name){
        this.name = name
    }
    speak(){
        console.log("My name is " + this.name)
    }
}
class Student extends Person{
    constructor(name, age){
        super(name)//调用父类构造器
        this.age = age
    }
    newSpeak(){
        this.speak()
        console.log(this.age)
    }
}
```
 - 寄生组合继承（`Object.create(原型对象)`）
```js
function Person(name){
    this.name = name
}
Person.prototype.speak = function(){
    console.log("My name is " + this.name)
}

function Student(name, age){
    Person.call(this, name)
    this.age = age
}

Student.prototype = Object.create(Person.prototype)
Student.prototype.constructor = Student
Student.prototype.newSpeak = function(){
    this.speak()
    console.log(this.age)
}
```
## 30、求一下二叉树高度
```js
var maxDepth = function(root) {
    if (root === undefined || root === null) return 0
    var maxDepth = 0
    function findDepth(chNode,Depth){
        if (chNode === undefined || chNode === null) return
        Depth++
        if(Depth > maxDepth) maxDepth = Depth
        findDepth(chNode.left,Depth)
        findDepth(chNode.right,Depth)
    }
    findDepth(root,0)
    return maxDepth
};
```
## 31、快速排序
```js
var sortArray = function(nums) {
    if(nums.length <= 1) return nums
    let newNums = [...nums]
    function sortFunc(left,right){
        if(left >= right) return 
        let i = left
        let j = right
        const temp = newNums[i]
        while(i < j){
            while(i < j && newNums[j] > temp) j--
            if(i < j) newNums[i++] = newNums[j]
            while(i < j && newNums[i] < temp) i++
            if(i < j) newNums[j--] = newNums[i]
        }
        newNums[i] = temp
        
        sortFunc(left,i - 1)
        sortFunc(i + 1,right)
    }
    sortFunc(0, newNums.length - 1)
    return newNums
};
```
## 32、讲一下双向绑定原理，实现vue双向绑定
基于数据劫持+发布-订阅模式，核心是通过Object.defineProperty()(es5) 或Proxy(es6) 监听数据变化，劫持各个属性的getter和setter，并在DOM更新时同步数据，核心原理是数据劫持，发布订阅模式，模板编译

**第一步**：需要observer的数据对象进行递归遍历，包含子属性对象的属性，都加上getter和setter
**第二步**：compile模板解析指令，把模板中的变量替换成数据，然后初始化渲染视图，同时把每个指令对应的节点绑定上更新函数，添加订阅者，如果数据变化，收到通知，更新视图
**第三步**：Watcher订阅者是Observer和Compile之间的通信桥梁：
	1. 在自身实例化的时候往订阅器内添加自己
	2. 自身要有一个update()方法
	3. 等待属性变动时，调用自身的update()方法，触发compile这种的回调
**第四步**：MVVM作为数据绑定的入口，这个和Observer、compile和watcher三者，通过observer来监听自己的数据变化，通过compile解析模板指令，最后利用watcher把Observer和compile联系起来，最终达到数据更新视图更新，视图更新数据更新的效果
## 33、TCP拥塞控制和双全工通信具体过程？
**TCP拥塞控制**：通过慢启动，拥塞避免，快速重传，快速恢复，动态调整发送窗口的大小，防止网络拥塞
**全双工通信**:通信双方可以同时发送消息，TCP通过两条独立的数据通道（发送和接收）实现，双方各自维护发送/接收缓冲区，通过ACK确认机制确保双向通信的可靠性
## 34、整个数组去重
1. ES6的Set
```js
function unique(arr){
	return [...new Set(arr)]
}
```

## 35、手写bind函数
1. 解构参数
2. 赋值返回新函数

```javascript
Function.prototype.bindFn = function(){
    const args = [...arguments]
    const t = args.shift()
    const self = this
    return function(){
        self.apply(t,args)
    }
}
```
## 36、Vue组件通信
1. 父传子
   通过属性传递数据
```vue
<!--Parent.vue-->
<template>
	<ChildComponent :message="parentMsg" :count="100"/>
</template>
<script setup>
import { ref } from 'vue'
const parentMsg = ref('来自父组件的消息')
</script>
```

```vue
<!--child.vue-->
<template>
	<div>{{ message }} - {{ count }}</div>
</template>
<script setup>
const props = defineProps({
	message: string,
	count:{
		type: Number,
		default: 0
	}
})
</script>
```

2. 子传父
   通过自定义事件
```vue
<!--Child.vue-->
<template>
	<button @click='sendMsg'></button>
<script setup>
const emit = defineEmits(['update','delete'])
const sendMsg = () => {
	emit('update',{ id: 1 , name:'666'})\
	emit('delete',1234)
}
</script>
```

```vue
<!-- Parent.vue -->
<template>
  <ChildComponent @update="handleUpdate" @delete="handleDelete" />
</template>
<script setup>
const handleUpdate = (data) => {
  console.log('子组件更新数据:', data); // { id: 1, name: '666' }
};

const handleDelete = (id) => {
  console.log('删除ID:', id); // 123
};
</script>
```

3. 使用Pinia跨层级
## 37、Vue2和3的区别
1. 性能优化：改Object.defineProperty为Proxy，虚拟DOM重写，diff算法优化
2. 增加了组合式API，setup语法
3. 在生命周期上，将vue2的beforeCreate/created两个钩子函数改为了setup()，beforeDistory/distoryed更名为beforeMount/moubted，钩子函数是在前面加on
4. 更好的支持TS
5. 打包体积更小
## 38、解释一下虚拟DOM和diff算法

**虚拟DOM**：是轻量的JS对象，描述元素和元素之间的关系，表示真实的DOM结构，能避免直接操作DOM，提升性能。数据发生变化时，render函数会生成一个新的虚拟DOM去和旧的虚拟DOM使用Diff算法进行比对，返回一个patch对象存储两个DOM不同的节点位置，最后用patch里的信息去更新真实的DOM
**Diff算法**：
	1. 同级对比：只对比同层级的节点
	2. Key优化：复用相同的Key节点
	3. 双端对比（3的优化：头头、尾尾、头尾、尾头对比
	4. 批量更新：最后统一patch到真实的DOM

核心是最小化DOM操作
## 39、解释一下服务端渲染

1. 原理是在服务端生成完整的HTML直接返回给浏览器，不是在客户端js动态渲染CSR
2. 首屏加载更快，SEO友好，低网络环境体验更好
3. 实现方式有vue的Nuxt.js，React的Next.js，原生Node+模板引擎
4. 代价是服务器压力大，开发复杂度大
5. 常见于 _内容型网站_
## 40、如何指定 vite 插件 的执行顺序？
添加enforce字段，pre是在Vite核心插件前执行，默认（不填）是在vite核心插件后执行，post是在Vite构建流程最后执行
## 41、vite 插件 常见的 hook 有哪些？
1. 通用Hook有config,configResolved,transform,load
2. 构建用Hook，buildStart,buildEnd,renderChunk,generateBundle
3. 开发服务器Hook，configureServer,transformIndexHtml
## 42、Vite是否支持 commonjs 写法？
**开发模式**默认不支持，需要使用插件@originjs/vite-plugin-commonjs转换
**生产环境**构建时会通过Rollup将其转换为ESM
## 43、为什么说 vite 比 webpack 要快
1. 开发服务器启动快：webpack需要先打包再启动，vite是直接启动，按需编译
2. webpack在文件修改后重新打包整个bundle，vite只编译修改的文件，其他的不变利用浏览器直接加载ES模块，跳过打包步骤
3. vite用go编写的Esbuild进行预构建和转换
4. 缓存优化：依赖预构建，源码以http缓存头提供
Bundle是最终打包出的完整文件，包含源码+依赖+runtime
Chunk是构建过程中的代码片段，分为Initial Chunk和Async Chunk
Rollup是专注于ES Module的JavaScript打包工具，输出简洁，与Vite共享插件生态
## 44、vite 对比 webpack ，优缺点在哪
vite：开发速度快，优化生产构建，配置简单，原生支持ESM，TS，动态导入。
缺点是插件数量少，旧项目的兼容性差，相比WebPack的SSR方案更手动化
## 45、说一下iframe标签，以及优缺点
iframe可以在当前页面中嵌入另一个独立的html文档，具有隔离性（独立渲染），懒加载优化（延迟加载节省带宽），跨域通信（通过postMessage实现安全数据传递），兼容性强等优点
但是也有性能问题（占用额外的内存或CPU）阻塞父页面加载，对SEO不友好，布局问题，引发安全风险（如XSS或点击劫持）
## 46、说一下CSS中的选择器及其优先级
!important > 内联 > ID选择器 > 伪类选择器  > 属性选择器 > 类选择器 > 标签元素选择器 > 通配符*
优先级由权重值决定格式为（A，B，C，D）
A:!important 有则1 无则0
B:ID 选择器的数量
C:类/伪类/属性 的数量
D: 元素/伪元素的数量

从左往右逐级对比
相同级别后出现的覆盖
\* 和继承样式级别为0
内联样式为(1,0,0,0)

## 47、说一下Canvas和SVG画布的区别，优缺点
Canvas是位图画布，SVG是矢量图画布
Canvas是JS动态逐帧绘制，SVG是用DOM节点渲染
Canvas放大后会失真，SVG不会失真
Canvas在交互上需要手动计算坐标，SVG支持DOM事件
Canvas在性能上适合高频渲染如游戏，动画，SVG在节点多时性能较差
Canvas内容无法被搜索引擎抓取SEO较差，SVG创建的文本可被搜索
## 48、了解vite的构建流程吗
vite的构建分为开发模式和生产模式
**开发模式**：利用浏览器原生ESM实现快速启动和热更新
流程为：启动服务器（使用ESbuild预构建依赖），按需编译，热更新
**生产模式**：
利用Rollup打包，生成优化后的静态资源
流程为：依赖项构建，Rollup打包，资源处理（CSS抽离，静态资源处理），输出到dist目录
## 49、什么是ESM
ESM是ECMAScript Modules，是Javascript官方模块化方案，逐步取代commonjs，核心优势是静态分析，编译时就能确定依赖关系，打包时能自动删除未使用的代码，浏览器原生支持。
使用import/export声明式语法，模块是异步加载的，严格模式下顶层的this是undefined
## 50、说一下浏览器缓存策略
浏览器缓存是提升网页性能的关键机制，主要通过HTTP缓存头和缓存策略控制，核心分为 **强缓存** 和 **协商缓存** 
**强缓存**：无需服务器验证，浏览器直接使用本地缓存，不发送请求到服务器
通过设置Cache-Control参数，max-age=xxx 缓存有效期，no-cache 禁用强制缓存（走协商缓存） ，no-store完全禁用缓存，public允许代理服务器缓存，private仅浏览器缓存
**协商缓存**：浏览器携带缓存表示询问服务器，若资源未变则返回304，否则返回新资源
使用ETag+If-None-Match，首次请求，服务器返回ETag，值为哈希值，再次请求浏览器发送If-None-Match值为上次ETag的值，服务器通过对比文件哈希值，内容不变则缓存

敏感数据需要设置Cache-Control为no-store
用户正常访问二者皆生效，手动刷新强缓存不生效，强制刷新都不生效
请求头设置Cache-Control:max-age=0可以强制重新认证
## 51、了解XSS攻击吗，如何防止。
XSS是跨站脚本攻击，攻击者通过在网页中注入恶意脚本JS，当用户访问该页面时，脚本在浏览器中执行导致窃取Cookie，Session，篡改页面内容，发起恶意请求，劫持用户会话
XSS分为存储型XSS（恶意脚本存入数据库）将`<script></script>`插入评论区、反射性XSS（通过URL参数注入）、DOM型XSS（js动态插入恶意内容）使用document.write()
**防御措施**:
 - 输入过滤、输出转义，去除提交数据中的`<script>`标签，输出时将特殊字符转义，`<`用`&lt;`
   `>`用`&gt;`将`"`转移成`\x22`
 - 使用CSP内容安全策略，通过HTTP头限制资源加载，阻止内联脚本执行
 - 使用框架内置防御vue{{ date }}插值，v-html需显声明
 - 使用工具扫描漏洞或手动测试

## 52、JS由哪三部分组成
 - ECMAScript：JS的核心内容，描述了基础语法，数据类型
 - 文档对象模型（DOM）：DOM把整合HTML页面规划为元素构成的文档
 - 浏览器对象模型（BOM）：对浏览器窗口进行访问和操作

## 53、JS有哪些内置对象
String Boolean Number Array Object Function Math Date RegExp
Math:abs() sqrt() max() min()
Date:new Date() getYear()
Array
String:concat() length slice() split()

## 54、操作数组的方法
push() pop() sort() unshift() shift() reverse() concat() join() filter() ervery() some() reduce() isArray() findIndex() splice() slice()
哪些方法会改变原数组：
push() pop() unshift() shift() sort() reverse() splice()

## 55、怎么理解内存泄露
JS里面已经分配内存地址的对象，由于长时间没有释放或没办法清除，造成长期占用内存的现象，造成内存资源大幅度浪费，减缓运行速度
垃圾回收机制
因素：一些未声明直接赋值的变量，一些未清空的定时器，过度的闭包，一些引用的元素没有清除

## 56、new操作符具体做了什么？
