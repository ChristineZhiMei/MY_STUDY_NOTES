# 准备的面试八股文
## 1、JS的数据类型
 - 基本数据类型：Number,String,null,undefined,Boolen
 - 引用类型：function,Date,Array,Object
 - es6新增：symbol,set等
 
_两者区别_:
基本数据类型占用内存少，在栈内存中，方便查找，没有相互赋值共享问题。
引用类型在堆内存中，用引用指向，有赋值共享问题

## 2、变量类型检测
typeof:基本数据类型
instanceof:包装类String() Number()
constructor 局限性
Object.prototype.toStrong.call()
```js
var opt = Object.prototype.toString
console.log(opt.call('123'))
```
包装类：为了访问不报错，临时创建包装类，销毁

## 3、手动实现一个instanceof
```javascript
function instanceof2(Op,Yp){
    let O = Op
    let Y = Yp.prototype
    while(O !== null){
        if(O === Y){
            return true
        }
        Op = Op.__proto__
    }
    return false
}
```
## 4、http和https的区别
 - http是超文本传输协议，基于请求-响应，是明文传输，端口80
 - https是安全超文本传输协议，使用ssl加密传输协议，ssl需要ca发放的证书，是非对称加密，确保数据传输的安全，端口443

## 5、http状态码
 - 1XX：正在请求
 - 2XX：请求成功
 - 3XX：重定向
 - 4XX：客户端错误
 - 5XX：服务端错误


## 6、说一下闭包
函数嵌套函数，内层函数访问外层函数的作用域，内层函数的返回会被保存下来， 
```javascript
function init(name){
    return function displayname(){
	    console.log(name)
    }
}
var fo = init('123')
fo()
```

应用场景：
 - 创建私有变量
 - 延长变量的生命周期，可重复使用的变量
 - 防抖，节流
 - 函数嵌套函数避免全局污染

优缺点：
 - 一直存在内存中，不会被垃圾回收机制回收
 - 避免全局变量的污染
 - 私有变量的存在
 - 闭包较多时，会消耗内存，导致性能下降，在IE浏览器中可能导致内存泄露
 - 用完赋值为null

垃圾回收机制
 - 标记清除：变量离开环境标记为离开环境，被回收内存
 - 引用计数：计数为0被清除，声明后次数+1，同一个值被赋值给另一个变量，次数+1，引用类型值被赋值为其他引用则-1

## 7、说一下this指向
指向函数当前的调用者
 - 定时器中的this指向window
 - 找不到调用者指向window
 - 箭头函数指向

固定函数的执行者
 - bind()返回新的函数
 - call()
 - apply()

## 8、防抖和节流
防抖(Debounce)：
 - 在一定时间内只执行最后一次
 - 搜索框搜索输入
 - 文本保存
 - 使用定时器
```javascript
let timerId = null
function debounce(){
    if(timerId !== null){
        clearTimeout(timerId)
    }
    timerId = setTimeout(()=>{
        console.log(123)
    }, 1000)
}

```
节流（Throttle）:
 - 在一定时间内只执行一次函数
 - 快速点击，鼠标滑动，scroll事件，resize事件，下拉加载，视频播放时间记录

```javascript
let timerId = null
function Throttle(){
    if(timerId !== null){
        return
    }
    timerId = setTimeout(()=>{
        console.log(123)
        timerId = null
    },100)
}
```
 - lodash库中的Debounce和Throttle

## 9、说一说事件循环 
1. 单线程，同步异步
2. 同步给js引擎（微任务），异步给宿主环境（宏任务）
3. 同步放入执行栈，异步等待时机放入任务队列排队
4. 执行栈完成后，完成任务队列，反复循环查看执行，就是事件循环
主线程先执行同步任务，然后再去执行任务队列里的任务，如果在执行宏任务之前有微任务，就先执行微任务，全部执行完后等待主线程调用，调用完后再去任务队列中查看是否有异步任务，这样一个循环往复的过程就是事件循环
## 10、说一说原型和原型链以及其查找过程
 - 原型就是每个对象隐藏的Prototype属性指向原型对象
 - 使用__proto__访问，原型链是属性查找的路径，从对象沿原型链向上直至null
 - 使用prototype共享方法，new绑定原型
 - 所有对象最终继承自Object.prototype
 - 函数才有prototype属性（构造函数），对象有__proto__
 - class语法糖，ES6，本质还是原型链

## 11、说一下Promise
 - promise主要有两个参数，三个状态，resolve参数是个函数，同时表示请求成功，执行.then函数，reject是表示请求失败，执行.catch，状态分为pedding初始状态，fulfilled操作成功，rejected操作失败，状态一经改变，不会再变。
 - .then返回的也是一个promise对象 .then(onFulfilled,onRejected)
 - 一旦创建立即执行回调
 - 当处于pedding状态时，无法确定目前在哪个阶段

## 12、TCP三次握手四次挥手
**三次握手**
1. 客户端发送SYN=1（同步标识），ACK=0(确认标识)，随机序号seq=x
2. 服务端接收到消息，发送SYN=1，ACK=1，ack=x+1（确认号）,seq=y
3. 客户端收到服务端的确认后，检查ACK==1，ack==x+1,是的话则发送ACK=1,ack=y+1,让服务端再确认

**四次挥手**

两端都能发起
1. 客户端发起FIN+1 ACK=0,seq = x
2. 服务端确认后发送ACK = 1，ack=x+1 ,seq=y
3. 等待剩余数据传输完成，服务端发送ACK=1 FIN=1 ack=x+1 seq=y
4. 客户端收到FIN=1和ACK=1后发送ACK=1，ack=y+1 seq=y+1

## 13、OSI七层模型
 - 应用层：为软件之间的通信设的接口
 - 表示层：把数据转化为兼容的格式
 - 会话层：不同机器上建立的会话点，维护连接通信
 - 传输层：把传输表头加至数据形成数据包
 - 网络层：将网络表头加至数据包，决定数据的路径选择和转寄
 - 数据链路层：网络寻址，错误侦测和改错
 - 物理层：使用线缆，针脚，电压等方式传输原始比特流数据
## 14、TCP/IP四层模型
 - 应用层：是直接为应用进程提供服务的层
 - 传输层：主要是有可靠传输的TCP协议，特别高效的UDP协议。主要负责传输应用层的数据包。
 - 网络层：寻址建立网络连接
 - 链路层：在物理链路上传输数据帧
## 15、手写深拷贝
完全拷贝一个新的对象，在堆内存中开辟新的空间
1. 扩展运算符
2. JSON.parse(JSON.stringify())
3. 利用递归函数实现
```javascript
function exten(origin, deep){
    let obj = {}
    if( origin instanceof Array){
        obg = []
    }
    for(let key in origin){
        let value = origin[key]
        obj[key] = (!!deep && typeof value === 'object' && value !== null ) ? exten(value,deep) : value
    }
    return obj
}
```
 - 循环引用导致无限递归
 - 特殊类型，日期对象，正则表达式，原型链没保留，都指向的Object.prototype
 - 无法复制Symbol属性
 - 使用lodash库中的_.cloneDeep

## 16、promise.all
ES6中将多个Promise实例包装成一个Promise实例的方法
```javascript
let p1 = new Promise((resolve,reject) => {
    resolve("p1")
})
let p2 = new Promise((resolve,reject) => {
    reject("p2")
}).catch((resolve)=>{
    resolve('p22')
})
let p3 = new Promise((resolve,reject) => {
    resolve("p3")
})
let pAll = Promise.all([p1,p2,p3])
pAll.then(res=>{
    console.log(res)
})
```
pAll的状态是由三个共同决定的，都成功pAll才成功，多个失败只会捕获第一个

## 17、手写一个promise.all
```javascript
const myPromiseAll = (arr) => {
    return new Promise((resolve,reject) => {
        if(!Array.isArray(arr)){
            throw new TypeError('arguments must be a array')
        }
        var len = arr.length
        var resolveResult = []
        for(let i = 0 ; i < len ; i++){
            arr[i].then(data => {
                resolveResult.push(data)
                if(i == len - 1) resolve(resolveResult)
            }).catch(err => {
                return reject(err)
            })
        }
        
    })
}
```

## 18、HTTP/1.1 HTTP/2 HTTP/3 区别
1. 传输协议：
     - HTTP/1.1 基于TCP文本传输
     - HTTP/2 基于TCP二进制分帧
     - HTTP/3 基于UDP+QUIC（新传输协议）
2. 核心问题（队头阻塞）
     - HTTP/1.1 存在队头阻塞
     - HTTP/2 使用多路复用缓解，没有彻底解决
     - HTTP/3 基于QUIC，彻底解决
3. 关键特性：
     - HTTP/1.1 持久连接，管道化
     - HTTP/2 头部压缩，多路复用，服务器推送，需要HTTPS配个
     - HTTP/3 更快的握手，连接迁移，网络切断不断连，TLS加密

从TCP到UDP+QUIC，从文本到二进制，从解决应用层阻塞到彻底消除传输层阻塞，逐步优化弱网体验

## 19、Vue和React的区别
 - Vue采用模板语法和声明式渲染，上手门槛低；react使用JSX和函数式组件，强调组件组合与单向数据流，更注重逻辑复用和底层灵活
## 20、Vue3的生命周期
组件从创建到销毁的过程
创建
 - beforCreate：实例创建之前，数据是未加载状态，属性和方法都不能使用
 - created：在实例、数据加载后，能初始化数据，DOM渲染之前执行，修改数据不会更新视图
 挂载
 - beforeMounted：完成模板的编译，虚拟DOM已经创建完毕，在数据渲染前最后一次更改数据，修改数据不会更新视图
 - mounted：页面、数据渲染完成，编译好的模板挂载完毕，可访问DOM节点
 更新
 - beforeUpdate：组件数据更新之前使用，数据是新的，页面上的数据是旧的，组件即将更新，准备渲染，可修改数据
 - updated：render函数重新做了渲染，这时数据和页面都是新的，避免更新数据造成循环
 销毁
 - beforeUnmount：实例销毁之前，可以消除定时器等副作用函数
 - unounted：实例销毁后执行
 使用keep-alive会多出两个属性
  - activated：组件被激活时
  - deactivited：组件被销毁时
## 21、说一下MVVM
 - 是一种软件架构模式，核心是ViewModel作为桥梁实现数据与视图的双向绑定，避免开发者直接操作DOM，让数据变化自动反映到视图，视图交互也能自动更新数据，从而简化前端开发中的状态管理和视图更新逻辑。
 - 核心组成部分：
    - Model：数据模型，负责存储和管理业务数据
    - View: 用户界面，负责展示数据和接收用户交互
    - ViewModel: 连接二者的中间层，通过数据绑定将Model的变化自动同步到View，同时将View的交互转化为对Model的操作
 - 核心优势：解耦数据与视图，提升代码的可维护性，简化复杂交互场景的卡发
## 22、Vue-Router是干什么的
是Vue的官方路由管理器，用于实现单页面应用的路由功能，它通过路径与组件映射实现页面切换，支持路由参数，导航守卫，懒加载等功能。让单页面应用在不刷新整个页面的情况下更新视图
## 23、Vue-Router的路由模式
 - hash模式，在URL后带#
     - 兼容性好，无需服务器配置
     - 带#不够美观
     - SEO（搜索引擎优化）效果差，爬虫无法正确解析，难以跟踪用户行为
 - history模式
     - URL更加美观，不带#
     - 需要服务端配置支持，兼容性较差
     - SEO效果好

_拓展问题_：如何优化SEO？
 - 使用服务端渲染SSR
 - 使用预渲染技术生成静态HTML页面
 - 使用合适的meta标签描述网页内容，包括标题，描述，关键字
 - 通过robots.txt文件确保SPA中的页面内容能够被搜索引擎爬虫访问到

## 24、js跨域问题
浏览器的同源策略限制（协议、域名、端口不同）的跨域请求
解决方法：
1. CORS(跨域资源共享)
	服务器设置响应头Access-Control-Allow-Origin
2. JSONP
   利用`<script>`标签不受同源限制，只支持GET请求
3. 代理服务器
   开发环境用Dev Server代理，生产环境用Nginx反向代理
4. WebSocket
   基于TCP协议，不受同源策略限制
## 25、事件模型，事件委托
**事件模型**:
 - 原始事件模型
	 - 直接在HTML标签或JS中绑定事件（onclick）
	 - 每个元素只能绑定一个同类事件，会被覆盖
 - DOM2级事件模型
	 - 使用addEventListener绑定事件，支持多个回调
	 - 事件流分为三个阶段：捕获->目标->冒泡
**事件委托**：
 - 利用事件冒泡，将事件监听器绑定到父级元素，通过event.target判断触发源
 - 减少DOM操作
 - 列表项点击
 - 使用event.stopPropagation()阻止事件冒泡
 - addEventListion('click' ,Func,true/false)，false是事件冒泡，true是事件捕获
 
```js
document.querySelector('ul').addEventListener('click',(e)=>{
	if(e.target.tagName === 'li'){
		console.log(e.target.textContent)
	}
})
```
## 26、实现trim方法
```js
String.prototype.trimFunc = function(){
    if(this === null){
        return undefined
    }
    let temp = this.slice(0,-1)
    let i = 0
    let j = temp.length - 1
    while(i<j){
        if(temp.charAt(i) === ' ') i++;
        if(temp.charAt(j) === ' ') j--;
        if(temp.charAt(i) !== ' ' && temp.charAt(j) !== ' ') break;
    }
    return this.slice(i,j+1)
}
```
## 27、实现模板字符串的过程
```js
function render(template,data){
    const regex = /\$\{([^}]+)\}/g
    return template.replace(regex,(_,variable)=>{
        return data[variable.trim()] || '';
    })
}
```
## 28、css实现三栏布局（双翼飞，圣杯布局）
 - float+负边距
```html
<body>
    <div class="container">
        <div class="left"></div>
        <div class="mid"></div>
        <div class="right"></div>
    </div>
    
</body>
<style>
    .container{
        padding:0 400px;
        background-color: aqua;
        overflow: hidden;
    }
    .left{
        position: relative;
        height:400px;
        width:400px;
        background-color:blue;
        float:left;
        margin-left: -400px;
    }
    .mid{
        height:400px;
        width: 100%;
        background-color:yellow;
        float: left;
        min-width: 100px;
    }
    .right{
        position: relative;
        height:400px;
        width:400px;
        float:left;
        background-color:green;
        margin-right: -400px;
    }
</style>
```
*注意*：三个盒子都要设置成float属性
## 29、实现一个继承
 - class语法糖
```js
class Person{
    constructor(name){
        this.name = name
    }
    speak(){
        console.log("My name is " + this.name)
    }
}
class Student extends Person{
    constructor(name, age){
        super(name)//调用父类构造器
        this.age = age
    }
    newSpeak(){
        this.speak()
        console.log(this.age)
    }
}
```
 - 寄生组合继承（`Object.create(原型对象)`）
```js
function Person(name){
    this.name = name
}
Person.prototype.speak = function(){
    console.log("My name is " + this.name)
}

function Student(name, age){
    Person.call(this, name)
    this.age = age
}

Student.prototype = Object.create(Person.prototype)
Student.prototype.constructor = Student
Student.prototype.newSpeak = function(){
    this.speak()
    console.log(this.age)
}
```
## 30、求一下二叉树高度
```js
var maxDepth = function(root) {
    if (root === undefined || root === null) return 0
    var maxDepth = 0
    function findDepth(chNode,Depth){
        if (chNode === undefined || chNode === null) return
        Depth++
        if(Depth > maxDepth) maxDepth = Depth
        findDepth(chNode.left,Depth)
        findDepth(chNode.right,Depth)
    }
    findDepth(root,0)
    return maxDepth
};
```
## 31、快速排序
```js
var sortArray = function(nums) {
    if(nums.length <= 1) return nums
    let newNums = [...nums]
    function sortFunc(left,right){
        if(left >= right) return 
        let i = left
        let j = right
        const temp = newNums[i]
        while(i < j){
            while(i < j && newNums[j] > temp) j--
            if(i < j) newNums[i++] = newNums[j]
            while(i < j && newNums[i] < temp) i++
            if(i < j) newNums[j--] = newNums[i]
        }
        newNums[i] = temp
        
        sortFunc(left,i - 1)
        sortFunc(i + 1,right)
    }
    sortFunc(0, newNums.length - 1)
    return newNums
};
```
## 32、讲一下双向绑定原理，实现vue双向绑定
基于数据劫持+发布-订阅模式，核心是通过Object.defineProperty()(es5) 或Proxy(es6) 监听数据变化，劫持各个属性的getter和setter，并在DOM更新时同步数据，核心原理是数据劫持，发布订阅模式，模板编译

**第一步**：需要observer的数据对象进行递归遍历，包含子属性对象的属性，都加上getter和setter
**第二步**：compile模板解析指令，把模板中的变量替换成数据，然后初始化渲染视图，同时把每个指令对应的节点绑定上更新函数，添加订阅者，如果数据变化，收到通知，更新视图
**第三步**：Watcher订阅者是Observer和Compile之间的通信桥梁：
	1. 在自身实例化的时候往订阅器内添加自己
	2. 自身要有一个update()方法
	3. 等待属性变动时，调用自身的update()方法，触发compile这种的回调
**第四步**：MVVM作为数据绑定的入口，这个和Observer、compile和watcher三者，通过observer来监听自己的数据变化，通过compile解析模板指令，最后利用watcher把Observer和compile联系起来，最终达到数据更新视图更新，视图更新数据更新的效果
## 33、TCP拥塞控制和双全工通信具体过程？
**TCP拥塞控制**：通过慢启动，拥塞避免，快速重传，快速恢复，动态调整发送窗口的大小，防止网络拥塞
**全双工通信**:通信双方可以同时发送消息，TCP通过两条独立的数据通道（发送和接收）实现，双方各自维护发送/接收缓冲区，通过ACK确认机制确保双向通信的可靠性
## 34、整个数组去重
1. ES6的Set
```js
function unique(arr){
	return [...new Set(arr)]
}
```

## 35、手写bind函数
1. 解构参数
2. 赋值返回新函数

```javascript
Function.prototype.bindFn = function(){
    const args = [...arguments]
    const t = args.shift()
    const self = this
    return function(){
        self.apply(t,args)
    }
}
```
## 36、Vue组件通信
1. 父传子
   通过属性传递数据
```vue
<!--Parent.vue-->
<template>
	<ChildComponent :message="parentMsg" :count="100"/>
</template>
<script setup>
import { ref } from 'vue'
const parentMsg = ref('来自父组件的消息')
</script>
```

```vue
<!--child.vue-->
<template>
	<div>{{ message }} - {{ count }}</div>
</template>
<script setup>
const props = defineProps({
	message: string,
	count:{
		type: Number,
		default: 0
	}
})
</script>
```

2. 子传父
   通过自定义事件
```vue
<!--Child.vue-->
<template>
	<button @click='sendMsg'></button>
<script setup>
const emit = defineEmits(['update','delete'])
const sendMsg = () => {
	emit('update',{ id: 1 , name:'666'})\
	emit('delete',1234)
}
</script>
```

```vue
<!-- Parent.vue -->
<template>
  <ChildComponent @update="handleUpdate" @delete="handleDelete" />
</template>
<script setup>
const handleUpdate = (data) => {
  console.log('子组件更新数据:', data); // { id: 1, name: '666' }
};

const handleDelete = (id) => {
  console.log('删除ID:', id); // 123
};
</script>
```

3. 使用Pinia跨层级
4. 兄弟传
   子->父->子
   事件总线
5. mitt实现任意组件通信
   npm安装mitt
```js
// emitter.js
import mitt from 'mitt'
export default mitt()
```
3. v-model
## 37、Vue2和3的区别
1. 性能优化：改Object.defineProperty为Proxy，虚拟DOM重写，diff算法优化
2. 增加了组合式API，setup语法
3. 在生命周期上，将vue2的beforeCreate/created两个钩子函数改为了setup()，beforeDistory/distoryed更名为beforeMount/moubted，钩子函数是在前面加on
4. 更好的支持TS
5. 打包体积更小
## 38、解释一下虚拟DOM和diff算法

**虚拟DOM**：是轻量的JS对象，描述元素和元素之间的关系，表示真实的DOM结构，能避免直接操作DOM，提升性能。数据发生变化时，render函数会生成一个新的虚拟DOM去和旧的虚拟DOM使用Diff算法进行比对，返回一个patch对象存储两个DOM不同的节点位置，最后用patch里的信息去更新真实的DOM
**Diff算法**：
	1. 同级对比：只对比同层级的节点
	2. Key优化：复用相同的Key节点
	3. 双端对比（3的优化：头头、尾尾、头尾、尾头对比
	4. 批量更新：最后统一patch到真实的DOM

核心是最小化DOM操作
## 39、解释一下服务端渲染

1. 原理是在服务端生成完整的HTML直接返回给浏览器，不是在客户端js动态渲染CSR
2. 首屏加载更快，SEO友好，低网络环境体验更好
3. 实现方式有vue的Nuxt.js，React的Next.js，原生Node+模板引擎
4. 代价是服务器压力大，开发复杂度大
5. 常见于 _内容型网站_
## 40、如何指定 vite 插件 的执行顺序？
添加enforce字段，pre是在Vite核心插件前执行，默认（不填）是在vite核心插件后执行，post是在Vite构建流程最后执行
## 41、vite 插件 常见的 hook 有哪些？
1. 通用Hook有config,configResolved,transform,load
2. 构建用Hook，buildStart,buildEnd,renderChunk,generateBundle
3. 开发服务器Hook，configureServer,transformIndexHtml
## 42、Vite是否支持 commonjs 写法？
**开发模式**默认不支持，需要使用插件@originjs/vite-plugin-commonjs转换
**生产环境**构建时会通过Rollup将其转换为ESM
## 43、为什么说 vite 比 webpack 要快
1. 开发服务器启动快：webpack需要先打包再启动，vite是直接启动，按需编译
2. webpack在文件修改后重新打包整个bundle，vite只编译修改的文件，其他的不变利用浏览器直接加载ES模块，跳过打包步骤
3. vite用go编写的Esbuild进行预构建和转换
4. 缓存优化：依赖预构建，源码以http缓存头提供
Bundle是最终打包出的完整文件，包含源码+依赖+runtime
Chunk是构建过程中的代码片段，分为Initial Chunk和Async Chunk
Rollup是专注于ES Module的JavaScript打包工具，输出简洁，与Vite共享插件生态
## 44、vite 对比 webpack ，优缺点在哪
vite：开发速度快，优化生产构建，配置简单，原生支持ESM，TS，动态导入。
缺点是插件数量少，旧项目的兼容性差，相比WebPack的SSR方案更手动化
## 45、说一下iframe标签，以及优缺点
iframe可以在当前页面中嵌入另一个独立的html文档，具有隔离性（独立渲染），懒加载优化（延迟加载节省带宽），跨域通信（通过postMessage实现安全数据传递），兼容性强等优点
但是也有性能问题（占用额外的内存或CPU）阻塞父页面加载，对SEO不友好，布局问题，引发安全风险（如XSS或点击劫持）
## 46、说一下CSS中的选择器及其优先级
!important > 内联 > ID选择器 > 伪类选择器  > 属性选择器 > 类选择器 > 标签元素选择器 > 通配符*
优先级由权重值决定格式为（A，B，C，D）
A:!important 有则1 无则0
B:ID 选择器的数量
C:类/伪类/属性 的数量
D: 元素/伪元素的数量

从左往右逐级对比
相同级别后出现的覆盖
\* 和继承样式级别为0
内联样式为(1,0,0,0)

## 47、说一下Canvas和SVG画布的区别，优缺点
Canvas是位图画布，SVG是矢量图画布
Canvas是JS动态逐帧绘制，SVG是用DOM节点渲染
Canvas放大后会失真，SVG不会失真
Canvas在交互上需要手动计算坐标，SVG支持DOM事件
Canvas在性能上适合高频渲染如游戏，动画，SVG在节点多时性能较差
Canvas内容无法被搜索引擎抓取SEO较差，SVG创建的文本可被搜索
## 48、了解vite的构建流程吗
vite的构建分为开发模式和生产模式
**开发模式**：利用浏览器原生ESM实现快速启动和热更新
流程为：启动服务器（使用ESbuild预构建依赖），按需编译，热更新
**生产模式**：
利用Rollup打包，生成优化后的静态资源
流程为：依赖项构建，Rollup打包，资源处理（CSS抽离，静态资源处理），输出到dist目录
## 49、什么是ESM
ESM是ECMAScript Modules，是Javascript官方模块化方案，逐步取代commonjs，核心优势是静态分析，编译时就能确定依赖关系，打包时能自动删除未使用的代码，浏览器原生支持。
使用import/export声明式语法，模块是异步加载的，严格模式下顶层的this是undefined
## 50、说一下浏览器缓存策略
浏览器缓存是提升网页性能的关键机制，主要通过HTTP缓存头和缓存策略控制，核心分为 **强缓存** 和 **协商缓存** 
**强缓存**：无需服务器验证，浏览器直接使用本地缓存，不发送请求到服务器
通过设置Cache-Control参数，max-age=xxx 缓存有效期，no-cache 禁用强制缓存（走协商缓存） ，no-store完全禁用缓存，public允许代理服务器缓存，private仅浏览器缓存
**协商缓存**：浏览器携带缓存表示询问服务器，若资源未变则返回304，否则返回新资源
使用ETag+If-None-Match，首次请求，服务器返回ETag，值为哈希值，再次请求浏览器发送If-None-Match值为上次ETag的值，服务器通过对比文件哈希值，内容不变则缓存

敏感数据需要设置Cache-Control为no-store
用户正常访问二者皆生效，手动刷新强缓存不生效，强制刷新都不生效
请求头设置Cache-Control:max-age=0可以强制重新认证
## 51、了解XSS攻击吗，如何防止。
XSS是跨站脚本攻击，攻击者通过在网页中注入恶意脚本JS，当用户访问该页面时，脚本在浏览器中执行导致窃取Cookie，Session，篡改页面内容，发起恶意请求，劫持用户会话
XSS分为存储型XSS（恶意脚本存入数据库）将`<script></script>`插入评论区、反射性XSS（通过URL参数注入）、DOM型XSS（js动态插入恶意内容）使用document.write()
**防御措施**:
 - 输入过滤、输出转义，去除提交数据中的`<script>`标签，输出时将特殊字符转义，`<`用`&lt;`
   `>`用`&gt;`将`"`转移成`\x22`
 - 使用CSP内容安全策略，通过HTTP头限制资源加载，阻止内联脚本执行
 - 使用框架内置防御vue{{ date }}插值，v-html需显声明
 - 使用工具扫描漏洞或手动测试

## 52、JS由哪三部分组成
 - ECMAScript：JS的核心内容，描述了基础语法，数据类型
 - 文档对象模型（DOM）：DOM把整合HTML页面规划为元素构成的文档
 - 浏览器对象模型（BOM）：对浏览器窗口进行访问和操作

## 53、JS有哪些内置对象
String Boolean Number Array Object Function Math Date RegExp
Math:abs() sqrt() max() min()
Date:new Date() getYear()
Array
String:concat() length slice() split()

## 54、操作数组的方法
push() pop() sort() unshift() shift() reverse() concat() join() filter() ervery() some() reduce() isArray() findIndex() splice() slice()
哪些方法会改变原数组：
push() pop() unshift() shift() sort() reverse() splice()

## 55、怎么理解内存泄露
JS里面已经分配内存地址的对象，由于长时间没有释放或没办法清除，造成长期占用内存的现象，造成内存资源大幅度浪费，减缓运行速度
垃圾回收机制
因素：一些未声明直接赋值的变量，一些未清空的定时器，过度的闭包，一些引用的元素没有清除

## 56、new操作符具体做了什么？
1. 先创建一个空对象
2. 把空对象和构造函数通过原型链链接
3. 把构造函数的this绑定到新的空对象上
4. 根据构建函数返回的类型推断，如果是值类型，则返回对象，如果是引用类型，则返回这个引用类型
```js
function newFunc(Fun,...args){
    if(typeof Fun !== 'function') throw new TypeError('')
    const newObj = Object.create(Fun.prototype)
    const result = Fun.apply(newObj,args)
    const getType = (value) => {
        return Object.prototype.toString.call(value).slice(8,-1)
    }
    return (getType(result) === 'Object' && result !== null ) || getType(result) === 'Function'  ? result : newObj
}
```


## 57、有没有用过CSS预处理器？
预处理器增加了变量，函数，混入等强大的功能
有SASS,LESS 最新的变为SCSS
选择器的嵌套，定义全局变量(@global : \#eee 定义全局变量@global值为\#eee) 
## 58、JS的设计原理
JS引擎：V8引擎，把代码转换成电脑可执行的代码
运行上下文：通过js的API让浏览器可以运行
调用栈、事件循环、回调：：js是单线程，当事件循环监听到调用栈为空时，将任务队列的回调函数添加到调用栈执行
## 59、script标签里的async和defer有什么区别
没有这两个属性是，浏览器会立即加载执行指定的脚本
有async：加载和渲染后面元素的过程将script的加载和执行并行进行，异步
有defer：也是异步但是要等待所有元素解析完成后才会执行script
减少阻塞渲染
## 60、setTimeout的最小执行时间是多少
setTimeout是4ms，setInterval的最小执行时间是10ms
## 61、ES5和ES6的区别
js的组成ECMAScript DOM BOM
ECMAScript5 2009第五次修订ECMAScript2009
ECMAScript6 2015第六次修订,是JS的下一个版本标准ECMAScript2015
## 62、ES6的新特性
1. 新增块级作用域（let const)
	   不存在变量提升
	   存在暂时性死区的问题
	   块级作用域的内容
	   不能再同一个作用域中重复声明
2. 新增定义类的语法糖（class）
3.  新增了一种基本数据类型（symbol）
4. 新增了解构赋值
   从数组或对象中取值，然后给变量赋值
5. 新增了函数参数的默认值（在形参上赋值）
6. 给数组新增了API
7. 对象和数组新增了扩展运算符
8. Promise
	   解决回调地狱的问题
	   自身有all,resolve,reject,race方法
	   原型上有then，catch，finally
	   把异步操作队列化
	   三种状态：pedding初始状态，fulfilled操作成功，rejected操作失败
	   状态改变后凝固
	   async await
		   同步代码做异步操作，二者搭配使用，返回Promise
		   如果await返回的Promise是reject状态，整个async都会被中断，后边的不执行
9. 新增了模块化（import,export)
10. 新增set和map数据结构
11. 新增generator
12. 新增箭头函数
	    不能作为构造函数使用
	    箭头函数没有原型
	    箭头函数没有arguments
	    箭头函数不能用call apply bind 改变this指向
	    this指向外层第一个函数的this

## 63、什么是暂时性死区
暂时性死区是指在代码块内，使用let或const命令声明变量之前，该变量处于不可用状态，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。提高代码的可靠性

## 64、JSON是什么？
轻量级的文本数据交换格式，本身不会提供任何的方法，适合在网络中进行传输。
JSON数据存在.json文件中，也可以把JSON数据以字符串的形式保存在数据库，Cookie中
JS 使用`JSON.parse()` ` JSON.stringify()`
什么时候使用JSON：定义接口、序列化；生成token，配置文件。

## 65、call，bind，apply
都是改变this指向和函数的调用，call和apply的功能类似，只是传参的方法不同，
bind传参不会立即执行，返回一个改变了this指向的函数，这个函数可以传参
call性能比apply性能要好

## 66、用递归的时候有没有遇到什么问题？

必须要有退出条件return 
## 67、AJAX是什么，怎么实现的
创建交互式网页应用的网页开发技术，在不重新加载整个网页的情况下，与服务器交换数据并更新内容
1. 通过XmlHttpRequest对象向服务器发送异步请求，然后从服务器拿到数据，最后通过JS操作DOM更新页面
2. 通过xhr对象里的open()方法和服务器建立连接
3. 构建请求所需要的数据，并通过xhr对象的send()发送给服务器
4. 通过xhr对象的onreadystate change事件监听服务器和通信状态
5. 接收并处理服务器响应的数据结果
6. 把处理的数据更新到HTML页面上
## 68、get和post的区别
1. get一般是获取数据，post一般是提交数据
2. get参数一般放在url上，安全性比较差，post放在body数据长度没有限制
3. get请求刷新服务器或退回是没有影响的，post请求退回是会重新提交数据
4. get请求时会被缓存，post不会被缓存
5. get请求可以保存在历史记录里，post不会
6. get只能进行url编码，post支持很多种

## 69、监控、埋点、日志上传
1. 监测应用运行状态，像js错误，API失败等，保障稳定性
2. 收集用户行为，如点击，曝光次数，转换率等，用于产品优化
3. 记录运行时信息（调试，故障排查等），排除问题
监控确保系统健康，埋点洞察用户行为，日志辅助问题定位，三者结合提升应用质量和用户体验

## 70、浏览器的存储方式有哪些
1. cookie:
	   兼容性好，请求头自带cookie，存储量小，永久存储，资源浪费，使用麻烦
2. localstorage
	   键值对的存储方式，操作方便，永久存储，兼容性好，保存值的类型被限定，隐私模式不可读取，不可爬取
3. sessionstorage
	   页面关闭后清除，会话级别的存储方式
4. indexedDB
	   H5标准的存储方式，以键值对进行存储，快速读取
## 71、token是存在哪里的
验证身份的令牌，一般是用户通过账户密码登录后，服务端把这些凭证，通过加密等一系列操作后得到的字符串
1. 存在localstorage里，后期每次请求接口都需要把它当成一个字段传给后台
2. 存在cookie中，会自动发送，缺点是不能跨域
如果存在localstorage中容易XSS攻击，如果做好了对应的措施，是利大于弊
如果存在cookie中会有CSRF攻击

## 72、你了解过JWT吗

**JSON Web Token**，通过JSON形式作为在web应用中的令牌，可以在各方之间安全的把信息作为JSON对象传输
信息传输，授权，单点登录
传统的session认证在每次认证后都要在服务端做一次记录，在认证量较大的时候，会增加开销；认证的记录保存在服务端内存，下一次访问要访问对应的服务端才能获取资源，在分布式的应用上限制了负载均衡的能力和扩展能力
JWT的认证流程
1. 前端把账号密码发给后端
2. 后端核对成功后把用户id等其他信息作为JWT负载，把它和头部分别进行base64编码拼接后签名，形成一个JWT
3. 前端每次请求时会把JWT放在HTTP请求头的Authorzation字段内
4. 后端检查是否存在，如果存在就验证JWT的有效性（签名是否正确，token是否过期）
5. 验证通过后后端使用JWT中包含的用户信息进行其他操作，并返回对应的结果
简洁、包含性、Token是JSON加密的形式保存在客户端，所以JWT是跨语言的，原则上是任何Web形式都支持

## 73、Token的登录流程
1. 客户端用账户密码请求登录
2. 服务器收到请求后，验证账户和密码
3. 客户端收到tocken后保存起来，可以放在cookie也可以放在localstorage
4. 客服端每次发起资源请求时，都会携带这个token
5. 服务器收到请求后，先验证客户端里的token，验证成功才会返回请求的数据
## 74、无感登录

无感登录是指在用户无感知的情况下，自动完成登录状态保持，避免频繁输入账号密码。核心是通过 **Token** 或 **Session** 机制实现
三种方法
 - 判断token过期后，调用刷新token的接口
	 - 登录成功后保存token和refresh_token
	 - 在响应拦截器中对401状态码引入刷新token的接口
	 - 替换保存本地新的token
	 - 把错误对象里的token替换掉
	 - 再次发送未完成的请求
	 - 如果refresh_token过期了，就清除所有的token并重新登录
 - 后端返回过期时间，前端判断token的过期时间，去调用刷印token的接口
 - 写定时器，定时刷印token接口
## 75、页面渲染的过程是怎样的
DNS解析
建立TCP连接
发送HTTP请求
服务器处理请求
渲染页面
	浏览器会获取HTML和CSS资源，然后把HTML解析成DOM树
	再把CSS解析成CSSOM
	把DOM和CSSOM合并成渲染树
	计算布局
	把渲染树的每个节点渲染到屏幕上
断开TCP连接
## 76、DOM树和渲染树有什么区别？
DOM树和HTML标签一一对应，包含head和隐藏元素
渲染树是不包含head和隐藏元素的
## 77、精灵图和base64的区别是什么
精灵图：把多个小图整合到一张大图上，利用定位的一些属性把小图显式在页面上，当访问页面时可以减少请求，提高加载速度
base64：传输8bit字节代码的编码方式，把原本的二进制形式转为64个字符的单位，最后组成字符串，base64是会和html css一起下载到浏览器中，减少请求，减少跨域问题，一些低版本浏览器不支持，若Base64体积比原图大，不利于css的加载
## 78、SVG格式了解多少
基于XML语法格式的图像格式，可缩放矢量图，其他图像是基于像素的，svg是属于对图像形状的描述，本质是文本文件，体积小，并且放大不会失真
1. SVG可直接插入页面中，成为DOM一部分，使用JS或CSS进行操作`<svg></svg>`
2. 可以作为文件被引入`<img src="pic.svg" />`
3. SVG可以转为Base64引入页面
## 79、npm的底层环境是什么
node package manager ,node的包管理和分发工具，已经成为分发node模块的标准，是js的运行环境
npm的组成：网站，注册表，命令行工具
## 80、HTTP协议规定的协议头和请求头
1. 请求头信息
		Accept：浏览器告诉服务器所支持的数据类型
		Host：告诉服务器我想访问服务器的哪台主机
		Referer：浏览器告诉服务器我是从哪里来的（防盗链）
		User-Agent：浏览器类型、版本信息
		Date：告诉服务器我是什么时候访问的
		Connection：连接方式
		Cookie
		X-Request-With：请求方式
2. 响应头信息：
		Location：告诉浏览器你要找谁
		Server：告诉浏览器服务器的类型
		Content-Type：告诉浏览器返回的数据类型
		Refresh：控制定时刷新
## 81、说一下什么是同源策略

浏览器安全的核心，没有这个策略就会遭到网络攻击，指协议域名端口号要保持一致，任意一个不一样就是同源，会产生跨域。
三个允许跨域的标签 img link script
跨域是可以发送请求，后端也会正常返回结果，只不过这个结果被浏览器拦截了
JSONP：利用script标签，浏览器的漏洞
CORS：设置Access-Control-Allow-Origin
websocket:H5的持久化协议，建立双向通信
反向代理：Nginx，建立中转站
## 82、当数据没有请求过来的时候，该怎么做
可以在渲染数据的地方使用默认的值
使用if判断有数据就显示没数据就隐藏

## 83、大文件上传是怎么做的
分片上传：
	1. 把需要上传的文件按照一定的规则分割成相同大小的数据块
	2. 初始化一个分片上传任务，返回本次分片上传的唯一标识
	3. 按照一定的规则把各个数据块上传
	4. 发送完成后服务端会判断数据上传的完整性，如果完整，那么就会把数据块合并成原始文件
断点续传：
	服务端告诉浏览器从哪里开始上传
## 84、vue中v-for的key值的作用是什么？
key是DOM元素的唯一标识
1. 提高虚拟DOM更新性能，减少DOM操作
2. 若不设置Key可能会触发一些BUG，列表更新某一条时影响其他的
3. 区分相同标签，为了触发过渡效果
## 85、Vue在created和mounted中去请求数据有什么区别
created：在渲染前调用，通常都是先初始化属性，然后被渲染
mounted：在模板渲染完成后，一般都是初始化页面后，再对元素节点进行操作，在这里请求数据会出现闪屏的问题。
一般created比较多
请求的数据对DOM有影响，那么使用created
对DOM无关使用mounted
## 86、Vue中的修饰符有哪些
1. 事件修饰符
   .stop：阻止冒牌
   .prevent：阻止默认行为
   .capture：内部元素出发的事件现在此处理
   .self：只有event.target是当前元素是触发
   .once：事件只会触发一次
   .passive：立即触发默认行为
   .native：把当前元素作为原生标签看待
2. 按键修饰符
   .keyup：按键抬起
   .keydow：按键按下
3. 系统修饰符
   .ctrl
   .alt
   .shift
   .meta
4. 鼠标修饰符
   .left
   .middle
   .right
5. 表单修饰符
   .lazy：等待输入完后再显示，失去焦点
   .trim：删除内容前后两端的空格
   .number：输入的是数字就转为数字
## 87、Element ui是怎么做表单验证的
1. 在表单中加rules属性，然后在data里写校验规则
2. 内部添加规则
3. 自定义函数校验
## 88、为什么用Tailwindcss
1. 原子化css，直接使用工具类减少手写代码样式
2. 响应式设计，内置断点前缀，轻松实现响应式布局
3. 仅生成实际使用的css，减少冗余代码，优化打包体积
4. 通过配置文件tailwind.config.js统一管理颜色，间距等规范
5. 直接在标签中编写样式，减少文件的之间的切换
6. 适合组件库开发，团队协作，快速开发，提升开发效率

## 89、Pinia 集中状态消费逻辑
1. 基于 `defineStore` 创建独立模块（state + actions + getters）,天然支持TS，类型推断友好
2. 组件内使用useStore()直接调用状态/方法
3. 相比Vuex有更简洁的API，能够使用组合式Store设计
4. 适合 **集中管理**、**跨组件共享** 或 **复杂状态逻辑**的场景
5. 购物车中的商品列表，总价计算优惠券等，用户详情信息，商品详情信息


## 90、Keep-alive是什么，怎么用
Vue的一个内置组件，包裹组件时，会缓存不活跃的组件实例，并不是销毁他们
作用：把组件切换的状态保存在内存中，防止重复渲染DOM节点，减少加载时间和性能消耗，提升用户体验
在Router中的meta属性中将keepAlive设置成true，不需要的设置成false，再在页面中使用v-for添加两个相同的router-view标签，一个被keep-alive包裹另一个不被包裹，再去判断route.meta.keepAlive的值来决定使用哪个
## 91、axios是怎么做封装的
下载 创建实例 封装请求响应拦截器 抛出 最后封装接口
```js
// axios.js
import axios from 'axios'
const api = axios.create({
    baseURL:'',
    timeout:3000
})
api.interceptors.request.use(config => {
    return config
} ,err => {
    return err
})
api.interceptors.reponse.use(res => {
    console.log(res)
    return Promise.resolve(res)
}, err => {
    Promise.reject(err)
})

export default api
```

```js
// request.js
import api from 'axios.js'
export const login = () => api({
    url:'www.bilibili.com',
    method:'get',
    parmas:params
})
```

## 92、vue路由怎么传参的
1. params传参
```js
import { useRoute , useRouter } from 'vue-router'
const route = useRoute()
const router = useRouter()

// 带参数跳转
router.push({name: 'user', params: { id: 2977 }})

//获取参数
const id = route.params.id
```
2. 路由属性传参
   `router.push({name:'/index/${item.id}})`
   路由配置：`{path:'/index:id'}`
3. query传参（可以解决页面刷新参数丢失的问题）
```js
router.push({
	name:'index',
	query:{id:item.id}
})
```

## 93、说一说动态路由
在路由配置中设置meta属性，扩展权限相关的字段，在路由导航守卫里通过判断这个权限标识，实现路由的动态增加和跳转
根据用户登录的账号，返回当前的用户角色
前端管理角色，根据路由表中的meta.role进行匹配
把匹配搭配的路由形成可访问的路由

## 94、解决刷新后二次加载路由
1. window.location.reload()
2. matcher
```js
const router = createRouter
export function resetRouter(){
	const newRouter = createRouter()
	router.matcher = newRouter.matcher
}
```
3. 使用keep-alive包裹路由出口
4. router.removeRoute()显式移除动态路由
## 95、pinia在什么场景下会去使用，属性有哪些

## 96、vue和jquery的区别
1. vue是数据绑定，jquery是先获取dom再处理
2. vue是数据驱动，jq是着重于页面
3. 操作不同，vue会自动更新DOM元素，只需要关注数据。
4. 未来发展不同，vue需求量大，完整的框架，jquery是js的库

## 97、vue遍历全局的方法有哪些
1. 普通遍历 对象.forEach()
```js
arr.forEach((item,index)=>{
	console.log(item,index)
})
```
2. 对元素统一操作 对象.map()
```js
var newArr = arr.map((item) => {
return item + 1
})
```
3. 查找符合条件的元素 对象.filter()
```js
arr.filter((item) => {
	if(item > 2){
		 return false
	}else{
		 return true	
	}
})
```
4. 查询符合条件的元素返回索引 对象.findIndex()
```js
arr.findIndex((item)=>{
	if(item > 1){
		return true
	}else{
		return false
	}
})
```
对象.evening()找到不符合的对象会停止
对象.some()找到符合条件的对象会停止
## 98、如何搭建脚手架
目前我对脚手架搭建的具体实现细节接触较少，但我理解他的核心目标是标准化项目初始化流程，是解决重复配置的问题。在我实际开发中我会使用`npm init vite@latest`快速生成项目。如果有机会的话我会深入研究他的实现原理，虽然目前我更多是使用现成脚手架，但理解其设计思想。如果有实际需求，我能通过查阅文档快速实现基础功能，并逐步优化
脚手架的核心设计思想是 **通过自动化工具减少重复劳动**，标准化前端项目的初始化流程，它的本质是一个 **工程化解决方案**，主要是**统一项目结构**、**集成最佳实践**、**依赖管理自动化**、**动态生成配置**、**隐藏复杂细节**

## 99、如何封装一个组件
1. 使用vue.extend()创建一个组件
2. 使用vue.component()方法注册组件
3. 如果子组件需要数据，可以在props中接收定义
4. 子组件修改好数据，要把数据传递给父组件，可以使用emit()方法
原则：
	把功能拆开
	尽量让组件原子化，一个组件只做一件事情
	容器组件管数据，展示组件管视图

## 100、Vue的过滤器如何使用，Vue3已经移除使用计算属性或方法替代
vue的特性，用来对文本进行格式化的处理
插值表达式，v-bind
分类：
1. 全局过滤器
```js
Vue.filter('add',(v) => {
	return v < 10 ? '0' + v : v
}) 

{{ message | add }}
```
## 101、vue如何做强制刷新
1. localtion.reload()
2. router.go(0)
3. provide和inject
小型项目可用 `provide/inject` 替代 Pinia/Vuex。
跨层级组件通信
```vue
<!-- Parent.vue -->
<script setup>
import { provide , ref } from 'vue'
const refreshKey = ref(0)
const forceUpdate = () => refreshKey.value++;
provide('forceUpdate', forceUpdate);
</script>
```

```vue
<!-- Child.vue -->
<script setup>
import { inject } from 'vue'
const forceUpdate = inject('forceUpdate')
</script>
<template>
<button @click="forceUpdate">强制刷新子组件</button>
</template>
```

4. v-if 销毁再创建
5. 修改key值（最佳）
## 102、vue性能优化怎么做
1. 编码优化
   不要把所有数据都放在data中
   v-for时给每个元素绑定事件代理
   keep-alive缓存组件
   尽可能拆分组件，提高复用性、维护性
   key值要保证唯一
   合理利用路由懒加载，异步组件
   数据持久化存储是尽量使用防抖和节流优化
2. 加载优化
   按需加载
   内容加载
   图片加载
3. 用户体验
   骨架屏
4. SEO优化
   预渲染
   SSR
5. 打包优化
   CDN形式加载第三方模块
   多线程打包
   抽离公共文件
6. 缓存和压缩
   客户端缓存、服务端缓存
   服务端Gzip压缩
## 103、首屏优化该如何去做

1. 使用路由懒加载
2. 非首屏组件使用异步组件
3. 首屏中不要的组件延迟加载
4. 一些静态资源放在CDN上
5. 减少首屏上js css等资源文件的大小
6. 使用服务端渲染ssr
7. 简历使用DOM的数量和层级
8. 使用精灵图请求
9. 做一些loading
10. 开启Gzip压缩
11. 图片懒加载
## 104、vue3的性能为什么比vue2好
1. diff算法的优化，对比新旧DOM的优化，对更新的位置打上标记，这样就避免了重复对比
2. 静态提升，没有参与到更新的元素不会重复渲染
3. 事件侦听缓存，对于动态绑定进行缓存，直接复用提升性能
## 105、vue3为什么用proxy
1. proxy可以代理整个对象，defineproperty只代理对象上的某个属性
2. proxy对代理对象的监听更加丰富
3. proxy代理对象会生成新的对象，不会修改代理对象
4. proxy不兼容IE浏览器（逐步淘汰
## 106、说一说你对组件的理解
可以重复的VUE实例，独一无二的组件名称
可以抽离单独的公共模块
提高代码的复用率
## 107、你是如何规划项目文件的
public/
	图标、index.html、img
src/
	api、assets
	components按分类再次划分子目录
	plugins
	router
	static
	styles
	utils
	views(pages)
App.vue
main.js
package.json
vue.config.js
## 108、是否使用过nuxt.js
它是基于VUE应用框架，关注的是渲染，可以开发 服务器端渲染（ssr）应用的配置，多页面应用
优势：
SSR生成的是有内容的HTML页面，有利于搜索引擎的搜索
优化了首屏加载事件
SEO:搜索引擎优化，增加流量
SAP的应用不利于搜索引擎SEO的操作

## 109、src href url区别
都是与资源引用相关，适用场景不同
1. src适合嵌入外部资源，成为页面的一部分，会有阻塞性
2. href建立关联链接，不会嵌入文档，是非阻塞性，导航，关联
3. url 通用的资源定位符，动态加载，表示资源的路径或地址，协议等

## 110、echarts有用过吗？常用的组件有哪些
1. title标题组件show text link
2. toolbox工具栏 导出图片 数据视图 切换 缩放 show orient feature
3. tooltip tigger 触发类型
4. markPoint标注点
5. markLine图标的标线
6. 

## 111、git如何合并，拉取代码
1. 拉取代码 `git pull` 仓库地址
2. 查看状态`git status`
3. 提交到本地缓存区`git add .`
4. 提交到本地仓库 `git commit -m '修改描述'`
5. 提交到远程仓库`git push '仓库地址' master`
6. 创建分支`git branch -b xxx`
7. 合并分支`git merge '分支名字'`

## 112、git如何解决冲突问题
1. 两个分支中修改了同一个文件
2. 两个分支中修改了同一个文件的名字
在当前分支上，直接修改代码 add commit
在本地当前分支上修改冲突代码 add commit push
## 113、你的优势在哪里
1. 尽量不要暴露自己的缺点
2. 不要过度美化自己
## 114、如何协同工作
1. 开发前会开个会议，确定开发文档，规定代码规范，变量名称等。
2. 利用工具保证项目的正常进度，规范化git、github等
## 115、路由拦截是怎么实现的
路由拦截、axios拦截
需要在路由配置中添加一个字段，它是用于判断路由是否需要拦截
```js
{
	name:'index',
	path:'/index',
	component:Index,
	meta:{
		requirAuth:true
	}
}
router.beforeEach((to,from,next) => {
	if(to.meta.requirAuth){
		if(store.getter.token){
			next()
		}else{
		
		}
	}
})
```

## 116、HTML5新增了那些标签
1. **布局标签（语义化标签）**
	**语义化的优点如下：**
		在没有CSS样式情况下也能够让页面呈现出清晰的结构
		有利于SEO和搜索引擎建立良好的沟通，有助于爬虫抓取更多的有效信息，爬虫是依赖于标签来确定上下文和各个关键字的权重
		方便团队开发和维护，语义化更具可读性，遵循W3C标准的团队都遵循这个标准，可以减少差异化
2. **视频标签(video)**
3. **音频标签(audio)**
4. **图片标签（img）**
5. **新的 API** canvas


## 117、Vue-Router 有哪几种路由守卫?
Vue-Router 提供了 **三类路由守卫**，用于在路由跳转前后执行逻辑（如权限校验、数据预加载）
 1. 全局守卫
	- **`router.beforeEach`（全局前置守卫）** 路由跳转 **前** 调用
	- **`router.beforeResolve`（全局解析守卫）**导航被确认 **前**，所有组件内守卫和异步组件已解析
	-  **`router.afterEach`（全局后置守卫）** 路由跳转 **完成后** ,日志记录、页面标题更新
2. 路由独享守卫（作用于特定的路由）
    - `beforeEnter` 对单个路由进行校验
3. 组件内守卫（作用于组件）
    - `beforeRouteEnter` 组件实例创建前调用，通过回调获取组件实例
    - `beforeRouteUpdate`当路由改变，但组件被复用时调用
    - `beforeRouteLeave`离开当前路由前调用
守卫执行顺序
 - 导航触发 - beforeRouteLeave（上一个组件的组件内守卫）
 - 全局 - beforeEach
 - 路由独享 - beforeEnter
 - 组件内 - beforeRouterEnter
 - 全局 - beforeResolve
 - 导航确认 - 更新视图
 - 全局 - afterEach
## 118、 Vue-Router 的钩子函数都有哪些?

## 119、computed和watch的区别
1. computed是计算属性，watch是监听data中数据的变化
2. computed是支持缓存，依赖的属性值发生变化，计算属性才会重新计算，否则缓存；watch不支持缓存
3. computed是第一次加载就监听，watch是不监听的
4. computed函数中必须有return ,watch不用

## 120、封装一个可复用的组件，需要，满足什么条件？
1. 低耦合，组件之间的依赖越小越好
2. 最好从父级传入信息，不要再公共组件中请求数据
3. 传入的数据一定要进行校验
4. 处理事件的方法写在父组件中

## 121、ref reactive区别
 - ref是适合所有类型，使用.value访问，方便重新赋值
 - reactive只支持对象类型，可以直接访问属性，适合复杂对象或嵌套结构，但是解构会丢失响应性
 - ref自动解包，reactive保持响应式嵌套
 当响应式的数据为基本类型值、需要替换整个对象、在模板中直接使用的简单值时用ref
 当数据为复杂对象或嵌套的数据结构时，需要保持引用一致性的对象，或者逻辑相关的多个属性结合的时候用reactive
 
 使用`toRefs`结构保持响应性
## 122、项目中遇到最难的问题是什么，怎么解决的
1. 不要回答没有问题
2. 不要说一些简单的问题。比如：数据请求不过来，渲染页面时出现问题，跳转路由不会，这些不要说
解决问题：首先检查自己的思路和代码有没有逻辑漏洞，然后再去CSDN或稀土掘金查询资料解决办法，如果身边没有经验丰富的人，我会去问AI，判断AI的方案的可行性后我会尝试对其优化，修改自己的思路或代码，解决问题后我会将其记录在笔记中以便之后遇到再次解决

## 123、说一说分布式原理
分布式原理的核心目标是：高可用，可扩展，容错性
关键技术有
 - 数据分片
 - 一致性协议
 - 负载均衡
 - CAP理论：只能满足其中一两项（一致性，可用性，分区容错性）
 典型场景：
	 微服务架构
	 分布式存储 HDFS
	 分布式计算（MapReduce、Spark）
总结来说是通过分片，复制，一致性协议实现高可用和扩展性，权衡CAP满足业务需求
