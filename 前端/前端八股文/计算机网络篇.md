# 关于TCP和UDP

## TCP 是用来解决什么问题？
TCP诞生的使命就是在“**不可靠，无序，易拥塞**”的IP网络之上，构建一条**可靠，有序，双向，流控，拥塞控制的“虚拟电路”**，让两端应用像**写入/读取**一条字节流一样简单而不用操心**丢包、乱序、重复、网络抖动**等底层问题
## TCP和UDP的十大核心区别
1. **连接方式不同**：
   TCP面向连接 即3次握手建立，4次挥手释放 
   UDP无连接
2. **可靠性不同**： 
   TCP使用序列化+ACK+重传，可以保证顺序，可靠，不丢不重 
   UDP可能丢，乱序，重复，不保证完全送达
3. TCP传输**字节流** 无明确消息边界，需应用层自行处理 
   UDP则传输/接受**独立报文**
4. **流量/拥塞控制**：
   TCP有流量窗口以及拥塞算法进行控制 
   UDP无流量控制，无拥塞控制发的快丢的多
5. **首部开销不同**：
   TCP首位有**20BYTE**起，带选项能达到**40~60BYTE** 
   UDP**固定8BYTE**，结构简单
6. **消息边界**：
   **TCP无标记**，需要应用层自行划分 
   **UDP有天然边界**，一包一消息
7. **适用场景**：
   TCP要求**可靠传输的场景**（如网页浏览、文件传输、电子邮件） 
   UDP要求**实时性优先**的场景（如视频流、语音通话、在线游戏、DNS查询）
8. **传输速度**：
   TCP稳定但握手+流量控制 **首包慢**，稳中求胜 
   UDP低延迟，抖动小，但需应用自行容错
9. **组播/广播** 
   TCP不支持 
   UDP原生支持单播/组播/广播
10. **稳定性成本** 
   TCP端口占用多、FD 常驻、握手耗 RTT 
   UDP 资源占用低、无状态，服务端易做并发

## UDP 头部为什么没有「首部长度」字段？
UDP头部长度固定为8字节，且总长度由“Length”字段和IP层报文长度共同决定，所以无需额外的“首部长度”字段。

## TCP 工作在哪一层？
当面试官问 “TCP 工作在哪一层？”——回答“传输层”即可，并可补充它是在 OSI 的第 4 层 / TCP-IP 的第 3 层（自下数）。
1. 端到端的可靠传输（序号、ACK、重传）
2. 流量控制（窗口机制）
3. 拥塞控制（慢启动、拥塞避免等）
4. 复用与分用（端口号）
5. 连接管理（三次握手、四次挥手）


## 服务器监听一个端口，TCP “最大连接数”怎么计算？
理论上几乎“无限”（2³² 级别），实际受操作系统内核资源和参数限制，通常业务场景 10 万～几百万就会到天花板。

## 既然 IP 层会分片，为何 TCP 层还需要 MSS？
IP 分片代价高且脆弱，TCP 用 MSS 在源头把数据段限制在路径 MTU 以内，以主动避免分片带来的性能损失与可靠性风险。

## TCP 的粘包 / 拆包机制是什么？
TCP 粘包/拆包问题本质是：**TCP 只负责“字节流”，不保消息边界，发送端打包快、接收端读包慢或网络层合并分段，都会导致多条业务消息一起到达(粘包)或被拆成碎片(拆包)**；因此必须由应用层自行“定界”或“定长”才能正确复原消息。

## 说说 TCP 的三次握手
三次握手=“我能发→你能收→我知道你能收”，两次握手保证不了双方 **都** 确认通路可用，而四次又可把“确认 + 发起”合并成一次包，因此恰好三次最经济；若任意报文丢失或主机发完 SYN 就宕机，TCP 都靠 **超时重传 + 半开连接清理** 机制自动收场。
>`两次 → 服务器心里没底` 
>`三次 → 你我都确认收到` 
>`四次 → ACK 与 SYN 合并一步就够` 
>`报文掉 → 超时重传` 
>`主机挂 → 半开清理 / SYN Cookie`

## TCP 初始序列号 ISN 怎么取值？
TCP 的初始序列号（ISN）由系统时钟驱动的递增算法或安全随机函数生成，既保证了序列号空间不重叠，也提升了抗预测攻击的安全性。

## 为什么每次建立连接 ISN 都要不同
每次建立连接时分配不同的初始序列号（ISN），是为了既避免网络中滞留的旧报文对新连接造成“旧信误投”，又抵御攻击者通过预测序列号进行会话劫持。

## 什么是 SYN Flood 攻击？如何避免？
SYN Flood 是通过大量伪造 TCP SYN 报文耗尽服务器「半连接队列」，导致合法连接被拒绝的拒绝服务（DoS）攻击。

## 为什么需要四次挥手？
- **双向释放**：关闭连接是半关闭的两次对称过程，共需四次报文
- **最后一次 ACK**：确认对方的 FIN，并进入TIME_WAIT重传机制，确保可靠释放
- **TIME_WAIT**：防止旧报文干扰新连接，以及保证 FIN/ACK 丢失时能重传机制使连接真正关闭

## 四次挥手各报文丢失会怎样？
- 四次挥手的每一步都有对应的 RTO 重传机制。
- 丢包后，发送方会重发 FIN/ACK，直到收到对方确认。
- 最后进入TIME_WAIT，可对抗最后一次 ACK 丢失并防止旧报文干扰新连接。

## 除了四次挥手，还有什么方法断开连接？
1. **四次挥手（FIN/ACK）**：优雅关闭，等待双方确认，确保数据可靠交互完成。
2. **RST 报文**：急迫中断，不再确认、立即释放资源，多用于错误处理或应用层要求“马上断”。
3. **使用场景**：SO_LINGER + close、协议错误触发、端口不可达时的拒绝应答等。

## 为什么挥手需要 TIME_WAIT？
- **TIME_WAIT** 是主动关闭方进入的最后阶段，时长为 **2×MSL**。
- 目的一：对方重传 FIN 时，能再次确认并发送 ACK；
- 目的二：防止旧报文滞留网络，干扰后续新连接。
- 虽然占用端口资源，但对于 **TCP 可靠性与正确性** 至关重要。

## TIME_WAIT 过多有什么危害？如何优化？
1. **危害**：端口资源枯竭、系统负载上升、连接失败或延迟。
2. **优化策略**：
    - 从**应用层**减少短连接（长连接/连接池）；
    - 在**内核层**调优tcp_fin_timeout、tcp_tw_reuse；
    - 必要时使用**急迫关闭**或**代理复用**。
3. **取舍**：优雅关闭与性能之间需平衡，根据业务场景选择最合适的方案。

## 已建立连接时客户端突然断电 / 进程崩溃会怎样？
1. **硬件或系统断电**：完全无法发 FIN/RST，服务器经重传/Keep-Alive 检测，最终超时放弃连接。
2. **进程崩溃**：OS 关闭 socket，会发送 FIN→四次挥手；若设置 SO_LINGER=0，则发送 RST→立即断开。
3. 服务器可通过调整 **TCP Keep-Alive**、**重传参数** 和 **应用超时** 来加快检测和释放资源。

## TCP 中何时会出现 RST 报文？
1. **RST 出现时机**
    - 新连接到达但目标端口未打开
    - 收到与当前连接不匹配或不合法的报文
    - 应用或内核触发“急迫关闭”
    - TIME_WAIT 阶段拒绝新 SYN
    - SYN_SENT 等待阶段收到拒绝或非法响应
2. **作用**
    - 立即中止连接，节省资源
    - 向对端明确告知“连接不存在或已被重置”
    - 防止旧/非法报文误伤新连接
3. **结果**
    - 发送方应用收到错误通知（ECONNRESET）
    - 连接状态瞬间进入CLOSED，不再保留任何半连接或 TIME_WAIT

通过 RST，TCP 在必要时能够迅速果断地结束一切通讯，保证协议的健壮性与安全性。

## TCP 协议如何保证可靠传输？
1. 序号+累积 ACK+超时重传 保证 **数据不漏、不乱**。
2. 校验和保证 **数据不损坏**。
3. 滑动窗口与流量控制 保证 **发送速率可控**。
4. 拥塞控制 保证 **网络不被压垮**。
5. SACK/时间戳等选项进一步 **优化效率与准确性**。
6. 多种机制协同，造就了 TCP 的端到端可靠传输。

## TCP 超时重传机制解决什么问题？
1. **报文丢失检测**：让发送端能在合适时间内察觉到丢包事件。
2. **自动恢复**：超时自动重发，保证最终数据到达。
3. **拥塞友好**：采用动态 RTO 与指数退避，平衡重传频率与网络负载。

TCP 超时重传机制正是端到端可靠传输的基石之一，与累计确认、滑动窗口、拥塞控制等机制一起，确保了 TCP 在不可靠的 IP 网络上也能可靠地传输数据。

## 有了超时重传为什么还需要快速重传？
超时重传需等到 RTO 到期才能重发，延迟较高；快速重传则利用「三个重复 ACK」信号，能在丢包之后更快地触发重发，显著缩短恢复时间、提升 TCP 性能。
## TCP 滑动窗口的作用是什么？
TCP 滑动窗口允许发送方在收到确认前**连续发送多段数据**，并根据接收方缓冲动态调整可发送量，从而实现流水线式传输与流量控制，极大提高带宽利用率。

## 流量控制和拥塞控制的步骤？
流量控制通过接收方广告窗口 (rwnd) 限制发送方速率以避免接收端缓冲溢出；
拥塞控制通过拥塞窗口 (cwnd) 及“慢启动→拥塞避免→快重传→快恢复”四个阶段动态调节发送速率，防范网络拥塞。


# 讲一讲TCP 半连接队列和全连接队列
TCP 在三次握手过程中，服务器先把收到 SYN 后尚未完成握手的连接放入**半连接队列**（SYN queue），待收到客户端 ACK 后再移入**全连接队列**（Accept queue），由应用层accept()依次取出，以此区分“握手中”和“已就绪”两种状态并保护系统免遭 SYN 洪水攻击。

# socket 通信的具体步骤是什么？服务端如何提速？
Socket 通信在 TCP 下经历 **socket→bind→listen→accept/connect→send/recv→close** 这六步完成端到端交互；
服务端提速则要从 **连接接入（backlog、SO_REUSEPORT）→I/O 模型（epoll/IOCP）→并发结构（线程池/协程）→零拷贝** 等多维度入手。

## TCP 和 UDP 可以使用同一个端口吗？
在操作系统里，TCP 和 UDP 端口号属于不同的协议命名空间（port‐space），同一台机器上可以同时在 TCP 层和 UDP 层“占用”同一个端口号，互不冲突。

## 如何在 UDP 之上实现可靠传输？
在 UDP 之上实现可靠传输，需要自行引入 **分段与序号、校验和、确认与重传、超时重传、流量/拥塞控制** 等机制，模拟 TCP 的可靠特性。

## 报文乱序怎么办？
对乱序报文，通过“**序列号 + 接收缓存 + 重排序算法**”把分片先缓存在本地，一旦缺口被填补就按序交付；在 TCP 中还可借助 SACK 通知发送端只重传缺失区间，保证上层收到的始终是有序数据。

## TCP 序列号 / 确认号如何变化？
TCP 的序列号（Seq）标记本报文段第一个字节在整个字节流中的位置，确认号（Ack）则告知对端“下一个期望”的字节序号；双方在三次握手时各自选定初始序号（ISN），此后 Seq 随已发字节数累加，Ack 则随已收字节数累加并反馈给对端。

## 已建立连接的 TCP 收到新的 SYN 会怎样？
在 ESTABLISHED 状态下收到新的 SYN 报文被视为“非法同步”，TCP 会按 RFC 793 发送带 ACK 的 RST 并关闭当前连接，拒绝把它当作“新连接”或“同时打开”处理。

## SYN 报文在什么情况下会被丢弃？
当 TCP 处于非 LISTEN/SYN_SENT 状态、半连接队列已满、报文校验或格式不合法，或因防火墙/ACL 策略拦截时，收到的 SYN 报文会被内核直接丢弃（有时还会回复 RST）。

## TCP 协议有什么缺陷？如何优化 TCP？
TCP 可靠有序，但因“三次握手/四次挥手”开销大、拥塞控制保守、HOL 阻塞及对高带宽-时延或无线环境不友好等缺陷，需要通过窗口扩展、SACK/Timestamp、Fast Open、新拥塞算法（CUBIC/BBR）、多路径（MPTCP）、零拷贝/硬件卸载等多种手段来优化。

## ping 的工作原理是什么
Ping 命令通过发送 ICMP Echo Request 报文并等待对端 ICMP Echo Reply 来检测网络连通性；而127.0.0.1属于回环地址，总在本机环回接口处理，即使外网断开也能相互「自嗨」式地 Ping 通。

--- 
# DNS篇
## 你对 DNS 的理解？
DNS 是一个分层、分布式的“互联网电话簿”，通过递归/迭代查询根、TLD、权威域名服务器，并结合多级缓存，把域名翻译成 IP 地址。

## DNS服务器有哪些？根服务器有多少个？
DNS 服务器可分为根服务器（13 组 Anycast 实例）、顶级域（TLD）服务器、权威域名服务器和递归解析器等；根服务器标准上只有 13 组（A~M），但每组通过 Anycast 在全球部署了数百台实例。

## DNS劫持了解吗？如何应对？
DNS 劫持是指攻击者通过篡改域名解析流程（Hosts、DNS 服务器或中间路由）返回伪造 IP，将用户导向恶意站点；应对之道在于端到端校验（DNSSEC）、加密传输（DoT/DoH）与使用可信解析器，并辅以监测与固件加固。

---
# 零碎知识点

## TCP、HTTP、FTP 分别属于哪一层？
在 TCP/IP 四层模型中，**TCP** 是传输层的“可靠投递员”，而 **HTTP** 和 **FTP** 都是应用层的“信件语言/快递服务”。

## OSI七层模型
- OSI 七层模型：
    1. 物理层——传输介质
    2. 数据链路层——本地链路封装与差错
    3. 网络层——跨网段路由
    4. 传输层——端到端可靠/不可靠传输
    5. 会话层——会话管理
    6. 表示层——格式转换与加密
    7. 应用层——应用协议接口

## 讲一下 TCP/IP 协议
TCP/IP 协议族通过 **链路层→网络层→传输层→应用层** 四层分工，从“物理连通”到“全局寻址”、再到“端到端可靠/不可靠传输”以及“应用数据交互”，共同构成了现代互联网的基石。
- **应用层**：各类网络应用协议，处理具体业务逻辑
- **传输层**：面向端口提供端到端通信
    - **TCP**：三次握手、可靠有序、滑动窗口、拥塞控制
    - **UDP**：无连接、尽力而为、延迟小
- **网络层**：以 IP 报文为单元，实现 **逻辑寻址**（IP 地址）与**跨网络路由**，并提供 ICMP 差错/诊断
- **链路层**：在局域网或点对点链路上发送帧 Frame，完成**物理寻址**（MAC），负责差错检测

## IPv4 和 IPv6 有什么区别？
IPv4 用 32 位地址、点分十进制表示、依赖 DHCP/NAT、可选头部杂乱、无内置安全；
而 IPv6 用 128 位地址、十六进制冒号表示、支持 SLAAC 自动配置、端到端不需 NAT、报文头简洁、内建 IPsec 和流标签，彻底解决地址枯竭与性能瓶颈。

## 应用层都包含什么协议？
应用层是 TCP/IP 四层模型或 OSI 七层模型的最顶层，负责为用户和应用程序提供各种网络服务协议，如
网页浏览（HTTP/HTTPS）
邮件收发（SMTP/POP3/IMAP）
文件传输（FTP/TFTP）
远程登录（SSH/Telnet）
名称解析（DNS）
网络管理（SNMP/DHCP）
时间同步（NTP）
物联网消息（MQTT/CoAP）等。

## 如何获取客户端真实 IP？
获取客户端真实 IP 需要在应用层首先通过套接字或 HTTP Header（如X-Forwarded-For/Forwarded/X-Real-IP/CF-Connecting-IP）读取地址，并结合反向代理或 CDN 的信任链配置，确保 Header 来源可信，才能拿到客观准确的最前端客户端 IP。

## NAT 的作用是什么？
NAT（网络地址转换）在路由器/网关上将内网私有地址与端口映射为公网地址与端口，实现私有网络访问互联网、节约 IPv4 地址、隐藏内网结构并提供端口转发等功能。

## 什么是 MAC 地址？
MAC 地址（Media Access Control Address）是网络接口卡（NIC）在数据链路层上全球唯一的 48 位硬件标识，相当于“局域网里的车牌号”，用于在同一网络内准确投递帧。

## CDN的原理与作用？
CDN（内容分发网络）通过在全球/全国部署大量边缘缓存节点，并结合 DNS/Anycast/HTTP 重定向技术，将用户请求就近接入最近的缓存节点，从而降低网络延迟、减轻源站压力、提升可用性和并发性能。

---
# HTTP篇
## HTTP/1.0、HTTP/1.1、HTTP/2.0、HTTP/3.0 的区别？
**HTTP/1.0**: 最初的标准，但是每个请求都需要独立的TCP连接，效率低下
**HTTP/1.1**: 引入了持久连接、管道化和缓存控制，成为近年来的主流，但是存在队头阻塞问题； **HTTP/2.0**: 引入二进制分帧、多路复用、头部压缩、服务器推送等，大幅度提升了性能；
**HTTP/3.0**: 基于QUIC协议，使用UDP代替TCP，解决了对头阻塞问题，提交连接速度。  

## HTTP 常见状态码有哪些？
1xx / 101 请求继续
2xx / 200 响应成功 
3xx / 302 302 重定向 
4xx / 404 客户端错误，找不到地址 
5xx 504 服务器错误 响应超时

## HTTP 是基于 TCP 还是 UDP？
“HTTP/1.x 和主流 HTTP/2 都基于 TCP；而 **HTTP/3 基于 UDP（具体说是基于 UDP 的 QUIC 协议）**。所以今天两种都存在，看版本而定。”

## HTTP 常见字段有哪些？
1. Host / UA / Referer / Origin ——「我是谁，从哪来」。
2. Content-* / ETag / Range ——「我带了啥，拆第几段」。
3. Cache-Control / If-* ——「能不能寄放驿站」。
4. Location / Upgrade ——「半路改道、换轨道」。
5. Cookie / Auth / STS / CSP ——「验身份，贴封条」。
6. CORS 六兄弟 ——「过海关要盖章」。
7. Connection / Transfer-Encoding ——「走陆路还是分批邮」


## HTTP 长连接 vs. 短连接的区别是？
“短连接”= **一次请求一次 TCP**；“长连接”= **一个 TCP 多次请求**。前者像一次性纸杯，用完即丢；后者是保温杯，喝完还能续水。

## 什么是重定向？重定向与请求转发的区别？
重定向是服务器返回 3xx 让浏览器重新访问新 URL（地址栏会改变，需二次请求）
而请求转发只在同一服务器内部把同一 request 转给其他资源处理（一次请求，地址栏不变）。

## GET 与 POST 有什么区别?

## HTTP vs. HTTPS 有什么区别?
| 维度         | HTTP                       | HTTPS                                            |
| ---------- | -------------------------- | ------------------------------------------------ |
| URL Scheme | http://                    | https://                                         |
| 端口默认       | 80                         | 443                                              |
| 传输层        | 直接跑在 TCP 之上                | 先经 **TLS**（SSL）再走 TCP；TLS 1.3 已与 QUIC 融合到 HTTP/3 |
| 加密         | ❌ 明文                       | ✅ 对称加密（AES/ChaCha20）                             |
| 完整性校验      | ❌ 无                        | ✅ MAC / AEAD，防篡改                                 |
| 身份认证       | ❌ 无                        | ✅ 服务器证书（可选客户端证书）                                 |
| 浏览器标识      | 无锁🔓 /Not Secure           | 小锁🔒 / 绿色安全                                      |
| SEO & 新特性  | 排名普通；Service Worker 禁用     | 谷歌排名加分；PWA、HTTP/2/3、Web Bluetooth 等强制 HTTPS      |
| 成本         | 证书零成本时代（Let’s Encrypt）依旧简易 | 需证书、配置、CPU 加解密                                   |
| 防御能力       | 易遭窃听、伪造、劫持（MITM）           | 防窃听、防篡改、防冒充，但**不**解决业务逻辑漏洞                       |
## WebSocket 简介 & 与 HTTP 的核心区别
`HTTP：写信—收信；一句话来一句话回。`
`WebSocket：电话—随时说；一次拨号聊到底。`
`需要实时、双向、低延迟 → 选 WebSocket`
`一次性请求/资源传输 → 选 HTTP(S)`
### WebSocket 是什么？
WebSocket 是一种运行在 **TCP** 之上的全双工、长连接、低开销通信协议，最早由 RFC 6455 标准化。它让浏览器和服务器之间建立“**持续通话**”——像打电话一样你一句我一句，而不必像 HTTP 那样“写信往返”。
- **一次握手、长期存活**：借助 HTTP Upgrade 只握手一次，随后复用同一 TCP 连接。
- **双向实时**：浏览器 & 服务器都能主动推消息；延迟可低至毫秒级。
- **帧格式轻量**：首部最小仅 2 Byte；支持文本帧、二进制帧、Ping/Pong 心跳。
- **原生跨域**：只要服务器响应Sec-WebSocket-Accept，浏览器即可连，不受 Same-Origin 限制。
- **加密**：wss://= WebSocket over TLS，安全性与 HTTPS 相当。
 线上聊天室、实时股价、在线游戏、协同编辑、IoT 推送、IM 即时通讯。

### WebSocket vs. HTTP —— 8 大维度差异
| 维度         | HTTP (1.x/2.x)                         | WebSocket                              |
| ---------- | -------------------------------------- | -------------------------------------- |
| **通信模式**   | 请求/响应，半双工                              | 全双工，任意端可先发                             |
| **连接生命周期** | 短连接（或 Keep-Alive），一事一连；HTTP/2 可多路复用    | 一次101升级后长驻                             |
| **首部开销**   | 每个请求动辄百字节                              | 最小 2 Byte，且无重复首部                       |
| **状态保持**   | 无状态；靠 Cookie / Token 维护会话              | 连接本身天然有状态                              |
| **服务器推送**  | 1.x 需轮询 / SSE；2.x 支持 Server Push 但仅限资源 | 任意时刻可send消息                            |
| **跨域限制**   | 受浏览器同源策略 & CORS                        | 握手时不检查 Origin，需服务端自控                   |
| **可靠性**    | TCP 级别可靠，但一次请求丢包不影响后续请求                | 同一连接丢包会阻塞双方，需心跳探活                      |
| **代理/缓存**  | HTTP 代理、CDN、缓存丰富                       | 需支持透明转发或显式Connection: Upgrade；中间节点多半旁路 |

