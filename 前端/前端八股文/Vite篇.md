# 介绍一下 tree shaking 及其工作原理
## 什么是tree shaking
 - 是指通过静态分析源代码，删除未被引用的代码，以减少文件体积，在javaScript中，tree shaking通常与ES6模块捆绑在一起使用，他能有效的帮我移除没有使用过的代码，提高应用的性能和加载速度
 - `ES6`的`import`语法可以完美使用`tree shaking`，因为可以在代码不运行的情况下就能分析出不需要的代码。
 - 因为`tree shaking`只能在静态`modules`下工作。`ECMAScript 6` 模块加载是静态的,因此整个依赖树可以被静态地推导出解析语法树。所以在 `ES6` 中使用 `tree shaking` 是非常容易的。

## Tree shaking的原理是什么？
 - `ES6 Module`引入进行静态分析，故而编译的时候正确判断到底加载了那些模块
 -  静态分析程序流，判断那些模块和变量未被使用或者引用，进而删除对应代码

### 其他回答
Tree-shaking 是一种优化 JavaScript 应用程序的技术，可以去除代码中从未被使用过的部分，以减少文件大小和提高性能。 
Tree-shaking 的原理是基于 ES2015 模块的静态解析特性。
当使用 ES2015 模块语法时，可以在代码中使用 import 和 export 关键字来声明依赖关系。这些依赖关系可以被静态分析，以确定哪些代码被使用，哪些代码未被使用。基于此，可以删除未使用的代码。 
在实际应用中，需要使用支持 Tree-shaking 技术的构建工具，如 Webpack、Rollup 等。这些工具可以根据依赖关系构建依赖图，然后使用 Tree-shaking 算法来删除未使用的代码，最终生成精简的代码包。

# common.js 和 es6 中模块引入的区别？
`CommonJS` 是一种模块规范，最初被应用于 `Nodejs`，成为 `Nodejs` 的模块规范。运行在浏览器端的 `JavaScript` 由于也缺少类似的规范，在 `ES6` 出来之前，前端也实现了一套相同的模块规范 (例如: `AMD`)，用来对前端模块进行管理。自 `ES6` 起，引入了一套新的 `ES6 Module` 规范，在语言标准的层面上实现了模块功能，而且实现得相当简单，有望成为浏览器和服务器通用的模块解决方案。但目前浏览器对 `ES6 Module` 兼容还不太好，我们平时在 `Webpack` 中使用的 `export` 和 `import`，会经过 `Babel` 转换为 `CommonJS` 规范。在使用上的差别主要有：
1. `CommonJS` 模块输出的是一个值的拷贝，`ES6` 模块输出的是值的引用。
2. `CommonJS` 模块是运行时加载，`ES6` 模块是编译时输出接口。
3. `CommonJs` 是单个值导出，`ES6 Module`可以导出多个
4. `CommonJs` 是动态语法可以写在判断里，`ES6 Module` 静态语法只能写在顶层
5. `CommonJs` 的 `this` 是当前模块，`ES6 Module`的 `this` 是 `undefined`

# 说一说你对vite的理解，什么是bundleless
1. 早期的模块化commonjs、amd、cmd 早期的浏览器支持的esm（es module）
2. 正式有了esm的浏览器的支持，才有了bundleless方案
3. bundleless打包，webpack是需要通过模块化规范支持，依赖分析完后构建依赖图depGraph。bundless提倡少打包，不打包
4. 打包js（ts、tsx、jsx、vue） css png svg 等输出到某一个指定目录
5. `<script type='module' src=...><script>`
6. 执行过程是栈的过程，先解析引用，入栈，再出栈使用
7. 热更新需要开发 开发服务器
8. 产物的构建机制
		产物的构建不是依赖打包工具，而是依赖 **编译** 工具
		webpack里面要编译 js 需要 babel
		 - 开发环境下，js 不用打包是直出的，打包的是代码资源，tsx等，css,字体资源
			 - 使用esbuild打包代码资源
			 - 使用postcss处理css
			 - 图片字体等使用类似于webpack的file node处理
			 - 需要针对需要打包的资源做转换的处理
			插件化机制来实现**vite-plugin-xxx**
			 - 优化
				 - 对已经编译的进行缓存
				 - 增量编译
				 - HMR
			 - 缺点：dts文件需要自行处理，es5以下不支持
		 - 构建环境
			 - 使用rollup打包
			 - 优化
				 - 构建工具来处理tree-shaking（是构建工具用的不是vite用的）

vite 是一款前端构建工具，其核心特点是采用了 bundleless 的开发模式。bundleless 即提倡少打包、不打包，这与 webpack 等传统打包工具的思路不同。​

早期的模块化规范有 commonjs、amd、cmd 等，而浏览器对 esm（es module）的正式支持，为 bundleless 方案奠定了基础。在有了 esm 支持后，我们可以使用<script type='module' src=...></script>的方式直接引入模块。​

vite 在开发环境下，js 不用打包而是直出的，对于 js（ts、tsx、jsx、vue）、css、png、svg 等资源，不是像 webpack 那样依赖打包工具进行大量打包后输出到指定目录，而是更多依赖编译工具。比如处理 js 时，webpack 需要 babel，而 vite 在开发环境下，使用 esbuild 打包代码资源，用 postcss 处理 css，图片字体等资源则类似 webpack 的 file node 处理方式，通过插件化机制如 vite-plugin-xxx 来实现各种功能。​

vite 的执行过程类似栈的过程，先解析引用入栈，再出栈使用。热更新需要开发服务器的支持，vite 通过优化手段，如对已编译内容进行缓存、增量编译和 HMR（热模块替换）来提升开发体验。​

在产物构建方面，vite 开发环境下不用打包，直出代码，而构建环境则使用 rollup 打包。产物的构建不依赖打包工具，而是依赖编译工具。不过，vite 也有一些缺点，比如 dts 文件需要自行处理，不支持 es5 以下的环境。​

记忆方式可以采用 “核心特点 + 关键环节 + 对比记忆” 法：​

- 核心特点：记住 vite 的 bundleless 模式，即少打包、不打包，这是与传统工具的最大区别。​

- 关键环节：将模块化发展（从早期规范到 esm 支持）、执行过程（栈的入栈出栈）、开发环境处理（esbuild、postcss 等工具的使用）、构建环境（rollup 打包）等关键环节串联起来，形成一条逻辑线。​

- 对比记忆：把 vite 与 webpack 进行对比，比如 webpack 依赖打包工具，vite 更多依赖编译工具；webpack 用 babel 处理 js，vite 开发环境用 esbuild 等，通过对比加深记忆。
# vite 的构建过程了解吗，说说其实现原理
开发构建
 - vite命令执行
 - 项目初始化：读取分析vite.config.js配置文件
 - 启动开发服务：基于express启动HTTP服务器
 - ESM支持：利用浏览器原生 ESM 进行模块加载
 - 按需编译：实时编译请求的模块
 - HMR（热更新）：通过WebSocket实现模块的局部更新
 - Source Maps：自动生成 Source Maps, 便于调试
打包
 - vite build
 - 项目初始化：读取配置文件vite.config.js
 - 入口解析：使用Rollup 构建模块依赖图
 - 插件处理：通过插件系统进行代码转换、压缩和资源处理
 - Tree Shaking：移除未使用的代码
 - 代码拆分：将代码拆分成多个模块
 - 输出内容：打包生成最终的输出文件
 - 资源优化：优化CSS和静态资源
 - 缓存处理：为静态资源添加内容哈希，便于缓存管理
vite 的构建过程主要分为开发构建和打包两个阶段，两者的实现原理各有侧重。​

开发构建阶段​

1. vite 命令执行：当开发者在终端输入vite命令时，会触发开发构建流程的启动。​

2. 项目初始化：系统会读取并分析项目根目录下的vite.config.js配置文件，该文件中的配置会决定开发服务的端口、插件使用、代理设置等关键信息。​

3. 启动开发服务：基于 express 框架启动一个 HTTP 服务器，这个服务器是开发过程中模块加载和热更新的基础。​

4. ESM 支持：利用浏览器原生的 ES 模块（ESM）机制进行模块加载。通过<script type='module' src=...></script>的方式引入入口文件，浏览器会自动解析模块依赖并发起请求。​

5. 按需编译：当浏览器请求某个模块时，vite 才会对该模块进行实时编译。例如处理 tsx、vue 等文件时，会借助相应的编译工具（如 esbuild）进行转换，转换后的代码直接返回给浏览器，实现了按需处理，提升了开发效率。​

6. HMR（热更新）：通过 WebSocket 建立浏览器与开发服务器之间的通信通道。当文件发生变化时，服务器会精确判断变化的模块，并只将该模块的更新信息发送给浏览器，浏览器再进行局部更新，无需刷新整个页面。​

7. Source Maps：自动为编译后的代码生成 Source Maps，方便开发者在浏览器调试工具中查看原始代码，提升调试体验。​

打包阶段​

1. vite build 命令执行：输入vite build命令后，进入打包阶段，用于生成生产环境的产物。​

2. 项目初始化：同样会读取vite.config.js配置文件，获取打包相关的配置，如输出目录、代码压缩方式等。​

3. 入口解析：使用 Rollup 工具构建模块依赖图。Rollup 会从入口文件开始，递归分析所有的模块依赖，形成完整的依赖关系图谱。​

4. 插件处理：通过 vite 的插件系统（如vite-plugin-xxx）对代码进行转换、压缩和资源处理。比如处理 CSS 时使用 postcss 插件，处理图片时使用相应的资源处理插件。​

5. Tree Shaking：借助 Rollup 的 Tree Shaking 功能，移除代码中未被使用的部分，减小产物体积。​

6. 代码拆分：按照一定的策略将代码拆分成多个模块，如将公共依赖提取为单独的 chunk，实现按需加载。​

7. 输出内容：将处理后的代码、资源等打包生成最终的输出文件，并存放在指定的目录（通常是dist目录）。​

8. 资源优化：对 CSS 进行压缩、合并，对静态资源（如图片、字体）进行优化处理，如压缩图片体积等。​

9. 缓存处理：为静态资源的文件名添加内容哈希，这样当资源内容未发生变化时，浏览器可以直接使用缓存，减少重复请求，提升页面加载速度。​

记忆方式​

可以采用 “阶段划分 + 关键步骤串联 + 核心工具关联” 法：​

- 阶段划分：明确区分开发构建和打包两个阶段，分别记忆每个阶段的核心目标（开发构建侧重快速响应和热更新，打包侧重产物优化和兼容生产环境）。​

- 关键步骤串联：在开发构建阶段，按照 “命令执行→初始化→启动服务→ESM 加载→按需编译→热更新→生成 Source Maps” 的顺序串联；在打包阶段，按照 “命令执行→初始化→入口解析→插件处理→Tree Shaking→代码拆分→输出内容→资源优化→缓存处理” 的顺序串联，形成清晰的流程线。​

- 核心工具关联：开发构建阶段关联 express（开发服务）、esbuild（编译）、WebSocket（热更新）；打包阶段关联 Rollup（构建依赖图、打包），通过工具与步骤的关联加深记忆。​


#  Vite.config.js里都是些什么内容?
https://blog.csdn.net/weixin_44803406/article/details/135654812