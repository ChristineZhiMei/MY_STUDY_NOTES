# 回流和重绘
## 什么是回流？
布局引擎会根据各种样式计算每个盒子在页面上的大小与位置

## 什么是重绘？
当计算好盒模型的位置、大小及其他属性后，浏览器根据每个盒子特性进行绘制

## 浏览器渲染机制
 - 解析HTML，生成DOM树，解析CSS生成CSSOM树
 - 将DOM树和CSSOM树结合，生成渲染树（Render Tree）
 - 根据生成的渲染树进行 **回流**，得到节点的几何信息
 - 根据渲染树以及回流得到的几何信息，得到节点的绝对像素值
 - 将像素绘制到页面上

## 触发回流和重绘
 - 页面渲染初始阶段触发回流和重绘
 - 修改DOM元素的几何尺寸，触发回流和重绘
 - 仅仅修改不影响几何属性的样式时，不需要重新计算元素的几何属性，直接为该元素绘制样式，也就是**不触发回流仅仅触发重绘**

### 触发回流：
 - 添加删除可见的DOM元素
 - 元素的位置或尺寸发生变化
 - 内容发生变化，比如文本变化或图片被另一个不同尺寸的图片所替代
 - 页面初始阶段渲染
 - 浏览器窗口尺寸变化
 - 即使计算才能获取到的值如：offsetTop...，scrollTop...，clientTop...(-Top、-Bottom、-Width、-Height)浏览器为了获取到这些值就要进行 **回流**

### 触发重绘
**触发回流就一定会触发重绘**
 - 颜色的改变
 - 文本方向的修改
 - 阴影的修改

## 如何减少回流和重绘
### 浏览器的优化机制
 - 大多数浏览器会通过队列化修改并批量执行来优化重排过程。
 - 把操作放入队列，达到一定阈值后才清空队列
 - 获取布局信息会强制清空队列来返回最新的信息

### 如何减少回流
 - 通过改变元素的类名来设定元素的样式
 - 避免设置多项内联样式
 - 应用动画的元素尽量使用fixed和absolute
 - 避免使用 **table** 布局
 - 使用CSS3硬件加速，可以让transform，opacity，filters这些动画不会引起回流重绘
 - 避免使用CSS的JavaScript表达式
 - 动态插入DOM节点时使用DocumentFragement创建后一次性插入，避免多次回流重绘
 - 减少动态获取节点信息的方法使用，使用变量显存储起来再使用变量
 - 使用类名合并样式，避免多次通过JS添加样式
 - 先讲元素设置display为none，然后在进行样式更改，再设置成block，这样又被称为离线操作

# 虚拟滚动
[参考CSDN](https://blog.csdn.net/qq_41560520/article/details/118100390)
	主要用于无法使用分页功能的长列表首屏加载速度慢问题，DOM加载过多无用元素
	对大量数据的 **懒加载**

## 核心
 - 元素监听scroll事件
 - 计算可视化高度一次能装几个列表，然后从数据中进行slice截取
 - 每一次滚动够根据scrollTop的值获取一个可以整除itemH结果进行偏移
![[Pasted image 20250703161759.png]]
## 实现方式
 - 使用VUEUSE封装好的vue-virtual-scroller库
 - JS/TS实现
```vue3

```
## 优化虚拟滚动的方法
### 1. 减少回流和重排
 - 使用absolute或fixed
 - 批量更新DOM元素

### 2. 优化滚动事件
使用节流或防抖

### 3. 图片懒加载

## 虚拟滚动在真实项目中的应用
 - 电商商品长列表
 - 大型数据表格列表
 - 社交媒体的无限滚动加载

# 前端开发小图片优化
在前端开发中，优化图片的加载速度和减少HTTP请求是提升用户体验的重要手段。

 - 精灵图：把多个小图整合到一张大图上，利用定位的一些属性把小图显式在页面上，当访问页面时可以减少请求，提高加载速度
 - base64：传输8bit字节代码的编码方式，把原本的二进制形式转为64个字符的单位，最后组成字符串，base64是会和html css一起下载到浏览器中，减少请求，减少跨域问题，一些低版本浏览器不支持，若Base64体积比原图大，不利于css的加载